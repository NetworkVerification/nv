type attribute = option[int]

let nodes = 4

let edges = {
 0=1;
 0=2;
 1=2;
 1=3;
 2=3;
}

symbolic fail = createDict false

let bool2int b = if b then 1 else 0

require
  let k = (bool2int (fail[(0,1)])) +
          (bool2int (fail[(1,0)])) +
          (bool2int (fail[(0,2)])) +
	  (bool2int (fail[(2,0)])) +
	  (bool2int (fail[(1,2)])) +
	  (bool2int (fail[(2,1)])) +
	  (bool2int (fail[(1,3)])) +
	  (bool2int (fail[(3,1)])) +
	  (bool2int (fail[(2,3)])) +
	  (bool2int (fail[(3,2)]))
  in
  k <= 2

let mapo f o =
  match o with
  | None -> None
  | Some x -> Some (f x)

let mapbetter f o1 o2 =
  match (o1, o2) with
  | (None, x) -> x
  | (x , None) -> x
  | (Some x, Some y) -> Some (f x y)

let merge node x y =
  mapbetter (fun x y -> if x < y then x else y) x y

let edge_failed edge =
  match edge with
  | 0~1 -> fail[(0,1)] || fail[(1,0)]
  | 1~0 -> fail[(1,0)] || fail[(0,1)]
  | 0~2 -> fail[(0,2)] || fail[(2,0)]
  | 2~0 -> fail[(2,0)] || fail[(0,2)]
  | 1~2 -> fail[(1,2)] || fail[(2,1)]
  | 2~1 -> fail[(2,1)] || fail[(1,2)]
  | 1~3 -> fail[(1,3)] || fail[(3,1)]
  | 3~1 -> fail[(3,1)] || fail[(1,3)]
  | 2~3 -> fail[(2,3)] || fail[(3,2)]
  | 3~2 -> fail[(3,2)] || fail[(2,3)]

let trans edge x =
  if edge_failed edge then None
  else mapo (fun x -> x + 1) x

let init node =
  match node with
  | 0n -> Some 0
  | _ -> None

let assert node x =
  match x with
  | None -> false
  | _ -> true
