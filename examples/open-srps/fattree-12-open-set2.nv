(* vim: set syntax=ocaml: *)
type attribute = set[int]


(* Open SRP version of fattree-12, looking at the racks.
   Racks are symmetrical so we're only looking at one side.

   This is the weaker example for this SRP.

   The inputs are weaker than the outputs of the spine in
   fattree-12-open-set.nv, and the outputs are stronger than
   the inputs of the spine in fattree-12-open-set.nv, i.e.
   input-spine is a subset of output-rack, and
   input-rack is a subset of output-spine.

   This is why the assertions at the end of this file and
   fattree-12-open-set.nv fail.
   If you were to change the inputs to be equal to the outputs,
   the assertions would no longer fail.
*)
let nodes = 12

(*
    Spine:
    4     5     6     7
    | \ /   \ /   \ / |
    *  *     *     *  *

    Racks:
    * *  * *
    |/  / /
    0   1/
    | x |
    2   3
    Subtract 4 to get original nodes on spine
    Add 4 to get original nodes on rack
*)
let edges = {
  0=2;
  0=3;
  1=2;
  1=3;
  0-4; (* out 0 *)
  0-5; (* out 1 *)
  1-6; (* out 2 *)
  1-7; (* out 3 *)
  8-0; (* in 0 *)
  9-0; (* in 1 *)
  10-1; (* in 2 *)
  11-1; (* in 3 *)
}

let merge node x y = x union y

let trans edge x = x

let init node =
  match node with
  | 0 -> let m = {} in
    m[4 := true]
  | 1 -> let m = {} in
    m[5 := true]
  | 2 -> let m = {} in
    m[6 := true]
  | 3 -> let m = {} in
    m[7 := true]
  | 8 -> let m = {} in
    m[0 := true]
  | 9 -> let m = {} in
    m[1 := true]
  | 10 -> let m = {} in
    m[2 := true]
  | 11 -> let m = {} in
    m[3 := true]
  | _ -> {}

(* This assertion should fail for nodes 8-11 (spine inputs).
   Since these are inputs, their internal values will not
   be updated, even though the outputs will correctly succeed.
*)
let assert node x = x[0] && x[1] && x[2] && x[3]



