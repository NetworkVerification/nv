(* vim: set syntax=ocaml: *)
type attribute = set[int]


(* Open SRP version of fattree-12, looking at a vertical cut.  *)
let nodes = 14

(*
    Spine:
    4     5
    | \ /   
    *  *    

    Racks:
    * *  * *
    |/  / /
    0   1/
    | x |
    2   3
*)
let edges = {
  0=2;
  0=3;
  1=2;
  1=3;
  0=4;
  0=5;
  1-6; (* 1, out6 *)
  1-7; (* 1, out7 *)
  4-8; (* 4, out8 *)
  5-9; (* 5, out8 *)
  10-1; (* in6, 1 *)
  11-1; (* in7, 1 *)
  12-4; (* in8, 4 *)
  13-5; (* in8, 5 *)
}

(* Return the base node associated with this input node *)
let inputs node =
  match node with
  | 10 -> Some 1
  | 11 -> Some 1
  | 12 -> Some 4
  | 13 -> Some 5
  | _ -> None

(* Return the base node associated with this output node *)
let outputs node =
  match node with
  | 6 -> Some 1
  | 7 -> Some 1
  | 8 -> Some 4
  | 9 -> Some 5
  | _ -> None

(* Our hypothetical destination *)
symbolic d : int
require 11 < d && d < 16

(* We consider link failure along the edges in a bidirectional sense. *)
symbolic fail04 : bool
symbolic fail05 : bool
symbolic fail16 : bool
symbolic fail17 : bool

let bool2int b = if b then 1 else 0

require
  let failed = (bool2int fail04) +
    (bool2int fail05) +
    (bool2int fail16) +
    (bool2int fail17)
  in failed <= 2

let edge_failed edge = 
  match edge with 
  | (0,4) -> fail04
  | (8,0) -> fail04
  | (0,5) -> fail05
  | (9,0) -> fail05
  | (1,6) -> fail16
  | (10,1) -> fail16
  | (1,7) -> fail17
  | (11,1) -> fail17
  | _ -> false

let merge node x y = x union y

let trans edge x = if edge_failed edge then {} else x


let init node =
  let inputset = { 4, 5, 6, 7, 12, 13, 14, 15 } in
    match node with
    | 0 -> { 0 }
    | 1 -> { 1 }
    | 2 -> { 2 }
    | 3 -> { 3 }
    | 8 -> inputset
    | 9 -> inputset
    | 10 -> inputset
    | 11 -> inputset
    | _ -> {}

(* If an output link fails, we naturally won't transmit any information along it *)
let assert node x =
  match outputs node with
  | Some base -> if edge_failed (base, node) then x = {} else x[d]
  | None -> x[d]

