(* vim: set syntax=ocaml: *)
include "utils.nv"

(* Each node keeps track of who its next hop is to and how long the total route is. *)
type route = { len: int; nexthop: tnode }
type attribute = option[route]

let test_route maybe_route min_len = match maybe_route with
  | Some r -> r.len >= min_len
  | None -> false

(* 10 node fattree, partitioned along the 4 bidirectional spine-pod edges *)
(* base_nodes = 10; input_nodes = 8; output_nodes = 8 *)
let nodes = 26

(* chosen destination: an arbitrary base node *)
symbolic dest : tnode
require 0n <=n dest && dest <=n 9n


(* node hypotheses *)
symbolic h0_2 : option[route]
symbolic h2_0 : option[route]
symbolic h1_3 : option[route]
symbolic h3_1 : option[route]
symbolic h0_6 : option[route]
symbolic h6_0 : option[route]
symbolic h1_7 : option[route]
symbolic h7_1 : option[route]

(* requirements on the hypotheses *)
require (test_route h0_2 0)
require (test_route h2_0 0)
require (test_route h1_3 0)
require (test_route h3_1 0)
require (test_route h0_6 0)
require (test_route h6_0 0)
require (test_route h1_7 0)
require (test_route h7_1 0)

(*
  Edge arrangement:
  0 to 2 and 6
  1 to 3 and 7

   0  1
  | \/ \
  | /\  \
  2 3 6 7
  |X| |X|
  6 7 8 9
*)
let edges = {
  (* cut 0=2 edge *)
  0-10;
  11-2;
  2-12;
  13-0;
  (* cut 0=6 edge *)
  0-14;
  15-6;
  6-16;
  17-0;
  (* cut 1=3 edge *)
  1-18;
  19-3;
  3-20;
  21-1;
  (* cut 1=7 edge *)
  1-22;
  23-7;
  7-24;
  25-1;
  (* uncut pod edges: left pod *)
  2=4;
  2=5;
  3=4;
  3=5;
  (* uncut pod edges: right pod *)
  6=8;
  6=9;
  7=8;
  7=9;
}

(* between two routes, pick the shorter one; 
 * if the routes have the same length, pick the one with the lower node number
 *)
let compare_routes r1 r2 =
  if r1.len < r2.len then r1 else if r1.len = r2.len && r1.nexthop <n r2.nexthop then r1 else r2

(* merge picks the shortest of two routes, or the one with the lowest AS number if they are the same *)
let merge node x y = match node with
  | _ -> mapbetter compare_routes x y

(* update a route to increase in size by one and give the specified node as the next hop *)
let update_route node r =
  let new_len = r.len + 1 in
  { len = new_len; nexthop = node }

(* the original trans broadcasts the updated route if a route exists, otherwise no route *)
let original_trans edge x = 
  let src = edge.src in
  mapo (fun r -> update_route src r) x

(* the final trans function in the partitioned SRP uses the original trans for all non-input edges
 * and the identity function for the others *)
let trans edge x = match edge with
  (* use identity for all input~base edges *)
  | 11~2 -> x
  | 13~0 -> x
  | 15~6 -> x
  | 17~0 -> x
  | 19~3 -> x
  | 21~1 -> x
  | 23~7 -> x
  | 25~1 -> x
  (* use original edge transfer for base~output edges *)
  | 0~10 -> original_trans 0~2 x
  | 2~12 -> original_trans 2~0 x
  | 0~14 -> original_trans 0~6 x
  | 6~16 -> original_trans 6~0 x
  | 1~18 -> original_trans 1~3 x
  | 3~20 -> original_trans 3~1 x
  | 1~22 -> original_trans 1~7 x
  | 7~24 -> original_trans 7~1 x
  (* otherwise use original transfer *)
  | _ -> original_trans edge x

let init node = if node = dest then
  Some { len = 0; nexthop = node } else 
  match node with
  | 11 -> h0_2
  | 13 -> h2_0
  | 15 -> h0_6
  | 17 -> h6_0
  | 19 -> h1_3
  | 21 -> h3_1
  | 23 -> h1_7
  | 25 -> h7_1
  | _ -> None

let assert node x = 
  match node with
  (* Check that the outputs satisfy the inputs *)
  | 10n -> test_route x 0
  | 12n -> test_route x 0
  | 14n -> test_route x 0
  | 16n -> test_route x 0
  | 18n -> test_route x 0
  | 20n -> test_route x 0
  | 22n -> test_route x 0
  | 24n -> test_route x 0
  (* Check that everyone can reach the destination *)
  | _ -> isSome x
