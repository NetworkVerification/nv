(* vim: set syntax=ocaml: *)
type attribute = set[int]

(* Open SRP version of fattree-12, looking at the spine.

   This is the strong example for this SRP.

   The inputs are equal to the outputs of the rack in
   fattree-12-open-set-strong2.nv, and the outputs are equal than
   the inputs of the rack in fattree-12-open-set-strong2.nv.

   This is why the assertions at the end of this file and
   fattree-12-open-set2-strong.nv succeed.
   If you were to change the inputs to be subsets of the outputs,
   the assertions would no longer succeed.
*)
let nodes = 20

(*
    Spine:
    0     1     2     3
    | \ /   \ /   \ / |
    *  *     *     *  *

    Lower tiers:
    * *  * *    * *  * *
    |/  / /      \ \  \|
    19 20/        \23 24
    | x |          | x |
    21 22          25 26

    numbers are +15 to accommodate inputs and outputs
    (4 is actually 19, 10 is actually 25, ...)
*)
let edges = {
  0-12; (* out 4 *)
  0-16; (* out 8 *)
  1-14; (* out 4 *)
  1-18; (* out 8 *)
  2-13; (* out 5 *)
  2-17; (* out 9 *)
  3-15; (* out 5 *)
  3-19; (* out 9 *)
  4-0; (* in 4 *)
  5-2; (* in 5 *)
  6-1; (* in 4 *)
  7-3; (* in 5 *)
  8-0; (* in 8 *)
  9-2; (* in 9 *)
  10-1; (* in 8 *)
  11-3; (* in 9 *)
}

let merge node x y = x union y

let trans edge x = x

let init node =
  match node with
  | 0 -> let m = {} in
    m[0 := true]
  | 1 -> let m = {} in
    m[1 := true]
  | 2 -> let m = {} in
    m[2 := true]
  | 3 -> let m = {} in
    m[3 := true]
  | 4 -> let m = {} in
    m[19 := true][20 := true][21 := true][22 := true]
     [0 := true][1 := true][2 := true][3 := true]
  | 5 -> let m = {} in
    m[19 := true][20 := true][21 := true][22 := true]
     [0 := true][1 := true][2 := true][3 := true]
  | 6 -> let m = {} in
    m[19 := true][20 := true][21 := true][22 := true]
     [0 := true][1 := true][2 := true][3 := true]
  | 7 -> let m = {} in
    m[19 := true][20 := true][21 := true][22 := true]
     [0 := true][1 := true][2 := true][3 := true]
  | 8 -> let m = {} in
    m[23 := true][24 := true][25 := true][26 := true]
     [0 := true][1 := true][2 := true][3 := true]
  | 9 -> let m = {} in
    m[23 := true][24 := true][25 := true][26 := true]
     [0 := true][1 := true][2 := true][3 := true]
  | 10 -> let m = {} in
    m[23 := true][24 := true][25 := true][26 := true]
     [0 := true][1 := true][2 := true][3 := true]
  | 11 -> let m = {} in
    m[23 := true][24 := true][25 := true][26 := true]
     [0 := true][1 := true][2 := true][3 := true]
  | _ -> {}

(* Note that the test "x[26]" would still not succeed here,
   because we can't merge in the information from the other
   nodes directly, even though we *know* that node 26 is
   reachable everywhere becaues the spine is reachable from
   everywhere. *)
let assert node x = x[0] && x[1] && x[2] && x[3](* && x[26] *)

