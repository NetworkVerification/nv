(* vim: set syntax=ocaml: *)
type attribute = set[int]


(* Open SRP version of fattree-12, looking at the racks.
   Racks are symmetrical so we're only looking at one side.

   This is the strong example for this SRP.

   The inputs are equal to the outputs of the spine in
   fattree-12-open-set-strong.nv, and the outputs are equal to
   the inputs of the spine in fattree-12-open-set-strong.nv.

   This is why the assertions at the end of this file and
   fattree-12-open-set-strong.nv succeed.
   If you were to change the inputs to be subsets of the outputs,
   the assertions would no longer succeed.
*)
let nodes = 12

(*
    Spine:
    4     5     6     7
    | \ /   \ /   \ / |
    *  *     *     *  *

    Racks:
    * *  * *
    |/  / /
    0   1/
    | x |
    2   3
    Subtract 4 to get original nodes on spine
    Add 4 to get original nodes on rack
*)
let edges = {
  0=2;
  0=3;
  1=2;
  1=3;
  0-4; (* out 0 *)
  0-5; (* out 1 *)
  1-6; (* out 2 *)
  1-7; (* out 3 *)
  8-0; (* in 0 *)
  9-0; (* in 1 *)
  10-1; (* in 2 *)
  11-1; (* in 3 *)
}

let merge node x y = x union y

let trans edge x = x

let init node =
  match node with
  | 0 -> let m = {} in
    m[4 := true]
  | 1 -> let m = {} in
    m[5 := true]
  | 2 -> let m = {} in
    m[6 := true]
  | 3 -> let m = {} in
    m[7 := true]
  | 8 -> let m = {} in
    m[0 := true][1 := true][2 := true][3 := true]
     [4 := true][5 := true][6 := true][7 := true]
  | 9 -> let m = {} in
    m[0 := true][1 := true][2 := true][3 := true]
     [4 := true][5 := true][6 := true][7 := true]
  | 10 -> let m = {} in
    m[0 := true][1 := true][2 := true][3 := true]
     [4 := true][5 := true][6 := true][7 := true]
  | 11 -> let m = {} in
    m[0 := true][1 := true][2 := true][3 := true]
     [4 := true][5 := true][6 := true][7 := true]
  | _ -> {}

(* This assertion should succeed for all nodes,
   as our hypotheses are much stronger now.
*)
let assert node x = x[0] && x[1] && x[2] && x[3]




