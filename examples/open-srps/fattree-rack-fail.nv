(* vim: set syntax=ocaml: *)
type attribute = set[int]


(* Open SRP version of fattree-12, looking at the racks.
   Racks are symmetrical so we're only looking at one side.
   We want to see if we can tolerate link failure going from the rack
   to the spine.

   More specifically, we want to test reachability of some destination d
   that we imagine is in the other rack.
*)
let nodes = 12

(*
    Spine:
    4     5     6     7
    | \ /   \ /   \ / |
    *  *     *     *  *

    Racks:
    * *  * *
    |/  / /
    0   1/
    | x |
    2   3
    Subtract 4 to get original nodes on spine
    Add 4 to get original nodes on rack
*)
let edges = {
  0=2;
  0=3;
  1=2;
  1=3;
  0-4; (* 0, out4 *)
  0-5; (* 0, out5 *)
  1-6; (* 1, out6 *)
  1-7; (* 1, out7 *)
  8-0; (* in4, 0 *)
  9-0; (* in5, 0 *)
  10-1; (* in6, 1 *)
  11-1; (* in7, 1 *)
}

(* Return the base node associated with this input node *)
let inputs node =
  match node with
  | 8 -> Some 0
  | 9 -> Some 0
  | 10 -> Some 1
  | 11 -> Some 1
  | _ -> None

(* Return the base node associated with this output node *)
let outputs node =
  match node with
  | 4 -> Some 0
  | 5 -> Some 0
  | 6 -> Some 1
  | 7 -> Some 1
  | _ -> None

(* Our hypothetical destination *)
symbolic d : int
require 11 < d && d < 16

(* We consider link failure along the edges in a bidirectional sense. *)
symbolic fail04 : bool
symbolic fail05 : bool
symbolic fail16 : bool
symbolic fail17 : bool

let bool2int b = if b then 1 else 0

require
  let failed = (bool2int fail04) +
    (bool2int fail05) +
    (bool2int fail16) +
    (bool2int fail17)
  in failed <= 2

let edge_failed edge = 
  match edge with 
  | (0,4) -> fail04
  | (8,0) -> fail04
  | (0,5) -> fail05
  | (9,0) -> fail05
  | (1,6) -> fail16
  | (10,1) -> fail16
  | (1,7) -> fail17
  | (11,1) -> fail17
  | _ -> false

let merge node x y = x union y

let trans edge x = if edge_failed edge then {} else x


let init node =
  let inputset = { 4, 5, 6, 7, 12, 13, 14, 15 } in
    match node with
    | 0 -> { 0 }
    | 1 -> { 1 }
    | 2 -> { 2 }
    | 3 -> { 3 }
    | 8 -> inputset
    | 9 -> inputset
    | 10 -> inputset
    | 11 -> inputset
    | _ -> {}

(* If an output link fails, we naturally won't transmit any information along it *)
let assert node x =
  match outputs node with
  | Some base -> if edge_failed (base, node) then x = {} else x[d]
  | None -> x[d]

