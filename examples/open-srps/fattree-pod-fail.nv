(* vim: set syntax=ocaml: *)
type attribute = set[int]


(* Open SRP version of fattree-12, looking at the racks.
   Racks are symmetrical so we're only looking at one side.
   We want to see if we can tolerate link failure going from the rack
   to the spine.

   More specifically, we want to test reachability of some destination d
   that we imagine is in the other rack.
*)
let nodes = 12

(*
    Spine:
    4     5     6     7
    | \ /   \ /   \ / |
    *  *     *     *  *

    Racks:
    * *  * *
    |/  / /
    0   1/
    | x |
    2   3
    Subtract 4 to get original nodes on spine
    Add 4 to get original nodes on rack
*)
let edges = {
  0=2;
  0=3;
  1=2;
  1=3;
  0-4; (* 0, out4 *)
  0-5; (* 0, out5 *)
  1-6; (* 1, out6 *)
  1-7; (* 1, out7 *)
  8-0; (* in4, 0 *)
  9-0; (* in5, 0 *)
  10-1; (* in6, 1 *)
  11-1; (* in7, 1 *)
}

(* Our hypothetical destination *)
symbolic d : int
require 11 < d && d < 16

(* We consider link failure along the edges in a bidirectional sense. *)
symbolic fail04 : bool
symbolic fail05 : bool
symbolic fail16 : bool
symbolic fail17 : bool

require
  let k = (bool2int fail04) +
    (bool2int fail05) +
    (bool2int fail16) +
    (bool2int fail17)
  in k <= 2

let edge_failed edge = 
  match edge with 
  | (0,4) -> fail04
  | (8,0) -> fail04
  | (0,5) -> fail05
  | (9,0) -> fail05
  | (1,6) -> fail16
  | (10,1) -> fail16
  | (1,7) -> fail17
  | (11,1) -> fail17
  | _ -> false

let merge node x y = x union y

let trans edge x = if edge_failed edge then {} else x

let init node =
  match node with
  | 0 -> { 0 }
  | 1 -> { 1 }
  | 2 -> { 2 }
  | 3 -> { 3 }
  | 8 -> { 4, 5, 6, 7, 12, 13, 14, 15 }
  | 9 -> { 4, 5, 6, 7, 12, 13, 14, 15 }
  | 10 -> { 4, 5, 6, 7, 12, 13, 14, 15 }
  | 11 -> { 4, 5, 6, 7, 12, 13, 14, 15 }
  | _ -> {}

let assert node x = x[d]

