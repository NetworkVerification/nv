(* vim: set syntax=ocaml: *)
type attribute = set[int]

(* Open SRP version of fattree-12, looking at the spine.

   This is the weaker example for this SRP.

   The inputs are weaker than the outputs of the rack in
   fattree-12-open-set2.nv, and the outputs are stronger than
   the inputs of the rack in fattree-12-open-set2.nv, i.e.
   input-spine is a subset of output-rack, and
   input-rack is a subset of output-spine.

   This is why the assertions at the end of this file and
   fattree-12-open-set2.nv fail.
   If you were to change the inputs to be equal to the outputs,
   the assertions would no longer fail.
*)
let nodes = 20

(*
    Spine:
    0     1     2     3
    | \ /   \ /   \ / |
    *  *     *     *  *

    Lower tiers:
    * *  * *    * *  * *
    |/  / /      \ \  \|
    19 20/        \23 24
    | x |          | x |
    21 22          25 26

    numbers are +15 to accommodate inputs and outputs
    (4 is actually 19, 10 is actually 25, ...)
*)
let edges = {
  0-12; (* out 4 *)
  0-16; (* out 8 *)
  1-14; (* out 4 *)
  1-18; (* out 8 *)
  2-13; (* out 5 *)
  2-17; (* out 9 *)
  3-15; (* out 5 *)
  3-19; (* out 9 *)
  4-0; (* in 4 *)
  5-2; (* in 5 *)
  6-1; (* in 4 *)
  7-3; (* in 5 *)
  8-0; (* in 8 *)
  9-2; (* in 9 *)
  10-1; (* in 8 *)
  11-3; (* in 9 *)
}

let merge node x y = x union y

let trans edge x = x

let init node =
  match node with
  | 0 -> let m = {} in
    m[0 := true]
  | 1 -> let m = {} in
    m[1 := true]
  | 2 -> let m = {} in
    m[2 := true]
  | 3 -> let m = {} in
    m[3 := true]
  | 4 -> let m = {} in
    m[19 := true][20 := true][21 := true][22 := true]
  | 5 -> let m = {} in
    m[19 := true][20 := true][21 := true][22 := true]
  | 6 -> let m = {} in
    m[19 := true][20 := true][21 := true][22 := true]
  | 7 -> let m = {} in
    m[19 := true][20 := true][21 := true][22 := true]
  | 8 -> let m = {} in
    m[23 := true][24 := true][25 := true][26 := true]
  | 9 -> let m = {} in
    m[23 := true][24 := true][25 := true][26 := true]
  | 10 -> let m = {} in
    m[23 := true][24 := true][25 := true][26 := true]
  | 11 -> let m = {} in
    m[23 := true][24 := true][25 := true][26 := true]
  | _ -> {}

(* This assertion should fail for nodes 4-7.
   Since these are inputs, their internal values will not
   be updated, even though the outputs will correctly succeed.
*)
let assert node x = x[26]


