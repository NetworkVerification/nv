type prefix = (int,int)
type edgeTy = (int,int)

type bgp = { fwdBgp : edgeTy; bgpad : int; lp : int; aslen : int; ibgp:bool; }
type rip = { fwdRip : edgeTy; ripad : int; cost: int; }

(* Because their may be both an iBGP and IGP route over an edge (I
   think?), we keep a forwarding edge for both protocols. The merge
   function should set the fwdEdge according to the protocol
   selected.*)
(* Note option around the record here does not work, Syntax.ml must be
   changed to find record types correctly *)
type ribEntry = {fwdEdge: edgeTy;
     	      	 igp: option[rip];
		 egp: option[bgp];
		 prot: int}

(* Packets are (for now) used solely to determine iBGP reachability *)
type packet = { srcIp: int; dstIp: int; }
type packets = set[packet]

type attribute = (packets, dict[prefix,option[ribEntry]])

let nodes = 5

(* 0,4 are external routers, 
   1 and 3 are border routers, 
   2 runs iBGP *)
let edges = {
  0=1;
  1=2;
  2=3;
  3=4;
  1=3; (* virtual link *)
 }

(* Data Plane functions *)
let mergePackets node x y = x union y

(* for this to work, rib must be a partial map *)
(* longestMatchingPrefix, should check whether p's headers match an
   entry in the rib and whether edge is the forwarding edge on that
   rib *)
let longestMatchingPrefix edge p rib =
  let dst = p.dstIp in
  match rib[(dst,32)] with
  | None -> false
  | Some r ->
     (* fwd = edge *)
     if (r.fwdEdge = edge) then true else false
(* just fwd = edge crashes in SMT... *)

let transPackets edge rib ps = 
  mapIf (fun p -> !(longestMatchingPrefix edge p rib)) (fun b -> false) ps

(*1 announces 1174405376
  2 announces 1174405888
  3 announces 1174405632 *)
let initPackets node =
  match node with
  | 1 -> {{ srcIp = 1174405376; dstIp=1174405632; },
          { srcIp = 1174405376; dstIp=1174405888; }}
  | 2 -> {{ srcIp = 1174405888; dstIp=1174405376; },
          { srcIp = 1174405888; dstIp=1174405632; }}
  | 3 -> {{ srcIp = 1174405632; dstIp=1174405376; },
          { srcIp = 1174405632; dstIp=1174405888; }}
  | _ -> {}

(* Control Plane functions *)
let flip edge =
  match edge with
  | (u,v) -> (v,u)

let edgeToPacket edge =
  match edge with
  | (1,3) -> { srcIp = 1174405376; dstIp=1174405632; }
  | (3,1) -> { srcIp = 1174405632; dstIp=1174405376; }
  | (1,2) -> { srcIp = 1174405376; dstIp=1174405888; }
  | (2,1) -> { srcIp = 1174405888; dstIp=1174405376; }
  | (2,3) -> { srcIp = 1174405888; dstIp=1174405632; }
  | (3,2) -> { srcIp = 1174405632; dstIp=1174405888; }
           
let transiBGP edge m soly =
  if (m.ibgp = true) then None
  else
    let (psy, riby) = soly in
    let ibgpPacket = edgeToPacket edge in
    (* does the ibgp packet reach the node receiving the attribute *)
    if psy[ibgpPacket] then
      (* and can that node forward back to the node that sent the attribute *)
      match riby[(ibgpPacket.srcIp,32)] with
      | None -> None
      | Some r ->     
         Some ({m with fwdBgp=r.fwdEdge; ibgp=true})
    else
      None
           
let transBgp edge m soly =
  match m with
  | None -> None
  | Some m ->
     (match edge with
      | (0,1) ->
         Some ({m with fwdBgp=flip edge; aslen=m.aslen+1; ibgp=false})
      | (1,0) ->
         Some ({m with fwdBgp=flip edge; aslen=m.aslen+1; ibgp=false})
      | (3,4) ->
         Some ({m with fwdBgp=flip edge; aslen=m.aslen+1; ibgp=false})
      | (4,3) ->
         Some ({m with fwdBgp=flip edge; aslen=m.aslen+1; ibgp=false})
      | (1,3) ->
         transiBGP edge m soly 
      | (3,1) ->
         transiBGP edge m soly
      | (1,2) ->
         transiBGP edge m soly
      | (2,1) ->
         transiBGP edge m soly
      | (2,3) ->
         transiBGP edge m soly
      | (3,2) ->
         transiBGP edge m soly)

let transRipAux edge c =
  match c with
  | None -> None
  | Some c ->
     if (c.cost) < 16 then Some ({c with fwdRip=flip edge; cost=(c.cost)+1})
     else None

let transRip edge c =
  match edge with
  | (1,2) -> transRipAux edge c
  | (2,1) -> transRipAux edge c
  | (2,3) -> transRipAux edge c
  | (3,2) -> transRipAux edge c
  | _ -> None
    
let transferRoute edge x soly =
  match x with
  | None -> None
  | Some x ->
     let newIgp = transRip edge (x.igp) in
     let newEgp = transBgp edge (x.egp) soly in
     match (newIgp, newEgp) with
     | (None, None) -> None
     | _ ->
        Some ({fwdEdge = edge; igp=newIgp; egp=newEgp; prot=0})
    
(* bgp attribute comparison *)
let betterBgp b1 b2 =
  if b1.lp > b2.lp then true
  else if b2.lp > b1.lp then false 
  else if b1.aslen < b2.aslen then true
  else false

(* rip attribute comparison *)
let betterRip x y =
  if x.cost < y.cost then true else false
           
let pickOption f x y =
  match (x,y) with
  | (None, None) -> None
  | (None, Some _) -> y  | (Some _, None) -> x
  | (Some a, Some b) ->
    Some (if f a b then a else b)

let best i b =
  match (i,b) with
  | (None, None) -> None
  | _ ->
     let i = match i with | None -> None | Some i -> Some ((i.fwdRip,0), (i.ripad)) in
     let b = match b with | None -> None | Some b -> Some ((b.fwdBgp,1), (b.bgpad)) in
     match pickOption (fun x y ->
               let (_,iad) = x in
               let (_,bad) = y in
               iad <= bad) i b with
     | None -> None
     | Some ((f,p), _) -> Some (f,p)

    
let mergeRoute lab1 lab2 =
  match (lab1, lab2) with
  | (None, None) -> None
  | (Some rib1, None) -> lab1
  | (None, Some rib2) -> lab2
  | (Some rib1, Some rib2) ->
     let i = pickOption betterRip (rib1.igp) (rib2.igp) in
     let b = pickOption betterBgp (rib1.egp) (rib2.egp) in
     (match best i b with
     | None -> None
     | Some (fwd, p) ->
        Some {fwdEdge=fwd; igp=i; egp=b; prot=p})
  
let initRoute node =
  let d = createDict None in
  match node with
  | 0 ->
     let b = {fwdBgp=(0,0); bgpad=20; lp=100; aslen=0; ibgp=false;} in
     let p = {fwdEdge=(0,0); igp=None; egp=Some b; prot=1} in
     d[(2399220480,24) := Some p]
  | 1 ->
     (* announces an internal loopback destination *)
     let i = {fwdRip=(1,1); ripad=120; cost=0} in
     let p = {fwdEdge=(1,1); igp=Some i; egp=None; prot=0} in
     d[(1174405376,32) := Some p]
  | 2 ->
     (* announces an internal loopback destination *)
     let i = {fwdRip=(2,2); ripad=120; cost=0} in
     let p = {fwdEdge=(1,1); igp=Some i; egp=None; prot=0} in
     d[(1174405888,32) := Some p]
  | 3 ->
     (* announces an internal loopback destination *)
     let i = {fwdRip=(3,3); ripad=120; cost=0} in
     let p = {fwdEdge=(3,3); igp=Some i; egp=None; prot=0} in
     d[(1174405632,32) := Some p]
  | _ -> d

(* Combined functions *)

let merge node x y =
  let (psx, labx) = x in
  let (psy, laby) = y in
  (mergePackets node psx psy, combine mergeRoute labx laby)

(* takes as argument the solution of the node that receives the attribute and
 the received attribute *) 
let trans edge y x =
  let (ps, rib) = x in
  (transPackets edge rib ps, map (fun r -> transferRoute edge r y) rib)

let init node =
  (initPackets node, initRoute node)
  
let assert node x =
  let (_, rib) = x in
  match node with
  | 4 ->
     (match rib[(2399220480,24)] with
      | Some _ ->
         true
      | _ -> false)
  | 3 ->
     (match rib[(2399220480,24)] with
      | Some _ -> false
      | _ -> false)
  | _ -> true
