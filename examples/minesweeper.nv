type attribute = option[int]

let nodes = 4

let edges = {
 0=1;
 0=2;
 1=2;
 1=3;
 2=3;
}

symbolic d : int = 5

require d >= 1 && d <= 6

symbolic fail01 : bool
symbolic fail02 : bool
symbolic fail12 : bool
symbolic fail13 : bool
symbolic fail23 : bool

let bool2int b = if b then 1 else 0

require
  let bool2int b = if b then 1 else 0 in
  let numFails = (bool2int fail01) +
                 (bool2int fail02) +
		 (bool2int fail12) +
		 (bool2int fail13) +
		 (bool2int fail23)
  in
  numFails <= 1

let mapo f o =
  match o with
  | None -> None
  | Some x -> Some (f x)

let mapbetter f o1 o2 =
  match (o1, o2) with
  | (None, x) -> x
  | (x , None) -> x
  | (Some x, Some y) -> Some (f x y)

let merge node x y =
  mapbetter (fun x y -> if x < y then x else y) x y

let edge_failed edge =
  match edge with
  | 0n-1n -> fail01
  | 1n-0n -> fail01
  | 0n-2n -> fail02
  | 2n-0n -> fail02
  | 1n-2n -> fail12
  | 2n-1n -> fail12
  | 1n-3n -> fail13
  | 3n-1n -> fail13
  | 2n-3n -> fail23
  | 3n-2n -> fail23

let trans edge x =
  if edge_failed edge then None
  else
    (*
    let (a,b) = edge in
    if a = 0 && d < 3 then None else *)
    let test =
    match edge with
      | 0n-1n -> d < 3
      | 0n-2n -> d < 3
      | _ -> false
    in
    if test then None else
    mapo (fun x -> x + 1) x

let init node =
  match node with
  | 0n -> if (d = 1) || (d = 2) then Some 0 else None
  | 1n -> if d = 3 || d = 4 then Some 0 else None
  | 2n -> if d = 5 then Some 0 else None
  | _ -> if d = 6 then Some 0 else None

let assert n x =
  match x with
  | None -> false
  | _ -> true
