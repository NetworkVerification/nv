(* An example demonstrating how Kirigami handles
 * statements over nodes in the monolithic network.
 * When partitioning, the assertNode test is encoded for each
 * partition by remapping 1n: in partition 1, 1n remaps to 0n.
 * In partition 0, 1n is cut, so the test must be changed to
 * be false.
 * However, because sol is a map which we unroll, the nodes are
 * already supplied to each equality, which means we get into
 * some trouble.
 * Instead of statements of the form:
 * In partition 0: `if false then true else v = 0`
 * In partition 1: `if u = 0n then true else v = 0`
 * We have statements of the form:
 * `if 0n = 1n then true else v = 0 && if 1n = 1n then true else v = 0`
 * which when reduced and remapped, both become:
 * `if false then true else v = 0` ==> `v = 0`
 * In order to properly handle this, we may instead need to remap
 * during map unrolling or beforehand to catch any operations that supply
 * nodes but could do so in the wrong order.
 *)
type attribute = int
let nodes = 2
let edges = {0=1;}

let init n = if n = 0n then 0 else 16
let trans e x = x + 1
let merge n x y = if x < y then x else y

let sol = solution { init = init; trans = trans; merge = merge; interface = interface; rtrans = trans }

let partition n = match n with
  | 0n -> 0
  | 1n -> 1

let interface e x = match e with
  | 0~1 -> x = 0
  | 1~0 -> x = 1

let assertNode u v = if u = 1n then true else v = 0

assert foldNodes (fun u v acc -> acc && assertNode u v) sol true
