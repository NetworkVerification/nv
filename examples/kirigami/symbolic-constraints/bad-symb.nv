(* An example where the interface constrains symbolic variables
 * and hides violations in the monolithic network. *)
type attribute = option[int]

symbolic d : int

let nodes = 2
let edges = { 0=1; }

let init n = match n with
 | 0n -> Some d
 | 1n -> None

let trans e x = match x with
 | Some a -> Some (a + 1)
 | None -> None

let merge n x y = match (x, y) with
 | (Some a, Some b) -> if a < b then x else y
 | (None, _) -> y
 | (_, None) -> x

let partition n = match n with
 | 0n -> 0
 | 1n -> 1

(* Interface that passes guarantees but restricts values of solutions *)
(*
let interface e x = match e with
 | 0~_ -> x = Some 0
 | 1~_ -> x = Some 1
*)

let sol = solution { init = init; trans = trans; merge = merge; interface = interface }

let pred u x = match x with
 | Some a -> a < 2
 | None -> false

assert foldNodes (fun u x acc -> acc && pred u x) sol true
