(* vim: set syntax=ocaml: *)
(* The DISAGREE example from Griffin et al., plus an extra node connected to 0.
 * Illustrates multi-solution fragments. *)

type attribute = option[int]

let nodes = 4
let edges = {
  0=1;
  0=2;
  1=2;
  0=3;
}

let init n =
  match n with
  | 0n -> Some 0
  | _ -> None

let trans e x =
  match x with
  | None -> None
  | Some x -> Some (x+1)

let merge n x y =
  match (x,y) with
  | (None, _) -> y
  | (_, None) -> x
  | (Some n1, Some n2) ->
    if n1 = 0 || n2 = 0 then Some 0 else (* 0 is most preferred *)
    if n1 = 2 || n2 = 2 then Some 2 else (* 2 is second most preferred *)
    if n1 < n2 then Some n1 else Some n2 (* Otherwise standard order *)

let sol = solution { init = init; trans = trans; merge = merge; interface = interface; }

(* Kirigami instrumentation *)
let partition n = match n with
  | 0n -> 0
  | 1n -> 0
  | 2n -> 0
  | 3n -> 1

let interface e x = match e with
  | 0~3 -> x = Some 0
  | 3~0 -> x = Some 1

let pred v x =
  match x with
  | Some y -> (match v with
    | 0n -> y = 0
    | 3n -> y = 1
    | _ -> y = 1 || y = 2)
  | None -> false

assert foldNodes (fun v x acc -> acc && pred v x) sol true
