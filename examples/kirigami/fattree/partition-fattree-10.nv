(* vim: set syntax=ocaml: *)
include "../../utils.nv"

(* Each node keeps track of who its next hop is to and how long the total route is. *)
type route = { len: int; nexthop: tnode }
type attribute = option[route]

(* --- Predicates ----------------------------------------------------------------- *)

(* predicate that a route r exactly has length l and nexthop n *)
let exact_route r l n = match r with
  | Some r -> r.len = l && r.nexthop = n
  | None -> false

(* predicate that a route r has length at least l and exactly nexthop n *)
let gt_min_len_route r l n = match r with
  | Some r -> r.len >= l && r.nexthop = n
  | None -> false

(* chosen destination *)
let dest = 9n

(* --- Topology ------------------------------------------------------------------ *)
(* 10 node fattree *)
let nodes = 10

(*
  Edge arrangement:
  0 to 2 and 6
  1 to 3 and 7

   0  1
  | \/ \
  | /\  \
  2 3 6 7
  |X| |X|
  4 5 8 9

*)
let edges = {
  0=2;
  0=6;
  1=3;
  1=7;
  2=4;
  2=5;
  3=4;
  3=5;
  6=8;
  6=9;
  7=8;
  7=9;
}

let partition node = match node with
  | 0n -> 0u8
  | 1n -> 0u8
  | _ -> 1u8

let interface edge = match edge with
  | 0~2 -> Some (fun a -> exact_route a 3 0n)
  | 2~0 -> Some (fun a -> gt_min_len_route a 4 2n)
  | 0~6 -> Some (fun a -> gt_min_len_route a 3 0n)
  | 6~0 -> Some (fun a -> exact_route a 2 6n)
  | 1~3 -> Some (fun a -> exact_route a 3 1n)
  | 3~1 -> Some (fun a -> gt_min_len_route a 4 3n)
  | 1~7 -> Some (fun a -> gt_min_len_route a 3 1n)
  | 7~1 -> Some (fun a -> exact_route a 2 7n)
  | _ -> None

(*
let interface edge = match edge with
  | 0~2 -> Some (Some { len = 3; nexthop = 0n })
  | 2~0 -> Some (Some { len = 4; nexthop = 2n })
  | 0~6 -> Some (Some { len = 3; nexthop = 0n })
  | 6~0 -> Some (Some { len = 2; nexthop = 6n })
  | 1~3 -> Some (Some { len = 3; nexthop = 1n })
  | 3~1 -> Some (Some { len = 4; nexthop = 3n })
  | 1~7 -> Some (Some { len = 3; nexthop = 1n })
  | 7~1 -> Some (Some { len = 2; nexthop = 7n })
*)
(* --- Policy Definition --------------------------------------------------------- *)

(* -------- Merge ---------------------------------------------------------------- *)
(* between two routes, pick the shorter one;
 * if the routes have the same length, pick the one with the lower node number
 *)
let compare_routes r1 r2 =
  if (r1.len < r2.len) then r1 else 
  if (r1.len = r2.len && r1.nexthop <n r2.nexthop) then r1 else r2

(* merge compares two routes and selects the best *)
let merge node x y = mapbetter compare_routes x y
(* NOTE: this definition shows that the SMT encoding of the output's solution
 * is the same as setting the output's solution to trans(L(base)),
 * because the base node is the output's only choice and its initial value is None
 *)

(* -------- Transfer ------------------------------------------------------------- *)
(* update a route to increase len by one and give this node as the next hop *)
let update_route node r =
  let new_len = r.len + 1 in
  { len = new_len; nexthop = node }

(* update the route if it exists, using the source node and ignoring the sink *)
let transfer_route src snk x = match (src, snk) with
  | (0n, 2n) -> mapo (fun r -> update_route 0n r) x
  | (0n, 6n) -> mapo (fun r -> update_route 0n r) x
  | (1n, 3n) -> mapo (fun r -> update_route 1n r) x
  | (1n, 7n) -> mapo (fun r -> update_route 1n r) x
  | (2n, 0n) -> mapo (fun r -> update_route 2n r) x
  | (2n, 4n) -> mapo (fun r -> update_route 2n r) x
  | (2n, 5n) -> mapo (fun r -> update_route 2n r) x
  | (3n, 1n) -> mapo (fun r -> update_route 3n r) x
  | (3n, 4n) -> mapo (fun r -> update_route 3n r) x
  | (3n, 5n) -> mapo (fun r -> update_route 3n r) x
  | (4n, 2n) -> mapo (fun r -> update_route 4n r) x
  | (4n, 3n) -> mapo (fun r -> update_route 4n r) x
  | (5n, 2n) -> mapo (fun r -> update_route 5n r) x
  | (5n, 3n) -> mapo (fun r -> update_route 5n r) x
  | (6n, 0n) -> mapo (fun r -> update_route 6n r) x
  | (6n, 8n) -> mapo (fun r -> update_route 6n r) x
  | (6n, 9n) -> mapo (fun r -> update_route 6n r) x
  | (7n, 1n) -> mapo (fun r -> update_route 7n r) x
  | (7n, 8n) -> mapo (fun r -> update_route 7n r) x
  | (7n, 9n) -> mapo (fun r -> update_route 7n r) x
  | (8n, 6n) -> mapo (fun r -> update_route 8n r) x
  | (8n, 7n) -> mapo (fun r -> update_route 8n r) x
  | (9n, 6n) -> mapo (fun r -> update_route 9n r) x
  | (9n, 7n) -> mapo (fun r -> update_route 9n r) x

(* the final trans function in the partitioned SRP uses the original trans for all non-input edges
 * and the identity function for the others *)
let trans edge x = match edge with
  | src~snk -> transfer_route src snk x

(* -------- Init ----------------------------------------------------------------- *)
let init node = if node = dest then
  Some { len = 0; nexthop = node } else None

(* -------- Assert --------------------------------------------------------------- *)
let assert node x = match node with
  | 0n -> isSome x
  | 1n -> isSome x
  | 2n -> isSome x
  | 3n -> isSome x
  | 4n -> isSome x
  | 5n -> isSome x
  | 6n -> isSome x
  | 7n -> isSome x
  | 8n -> isSome x
  | 9n -> isSome x

