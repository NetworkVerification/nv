"""
Utilities for generating RoEduNet benchmarks.
"""
import os
import sys


class NvFile:
    def __init__(self, name):
        self.name = name
        self.types = []
        self.consts = []
        self.funcs = []
        self.sols = []
        self.asserts = []

    def add_type(self, tname, ty_exp):
        self.types.append(f"type {tname} = {ty_exp}")

    def add_topology(self, nodes, edges):
        self.consts.append(f"let nodes = {nodes}")
        edge_list = "\n  ".join([f"{u}-{v};" for (u, v) in edges])
        self.consts.append(f"let edges = {{\n  {edge_list}\n}}")

    def add_let(self, fname, args, fbody):
        if len(args) > 0:
            argstr = " ".join(args)
            self.funcs.append(f"let {fname} {argstr} = {fbody}")
        else:
            self.consts.append(f"let {fname} = {fbody}")

    def add_solution(self, var):
        self.sols.append(
            f"let {var} = solution {{ init = init; trans = trans; merge = merge; }}"
        )

    def add_assert(self, exp):
        self.asserts.append(f"assert {exp}")

    def __str__(self):
        s = ""
        s += nv_comment(f"Generated by {os.path.basename(__file__)}") + "\n\n"
        s += "\n\n".join(
            self.types + self.consts + self.funcs + self.sols + self.asserts
        )
        return s


def RoEduNet():
    """7 groups of nodes"""
    nodes = list(range(0, 40))  # nodes numbered 1 to 40
    edges = {u: [] for u in nodes}  # key: node id, value: list of nbrs
    business_rel = {}  # key: pair (u, v); value: prov_cust / cust_prov / peer_peer
    p2p = "peer_peer"
    cust2prov = "cust_prov"
    prov2cust = "prov_cust"

    # group 1
    group1_prov = 0
    group1_cust = list(range(1, 10))

    edges[group1_prov].extend(group1_cust)
    for c in group1_cust:
        edges[c].append(group1_prov)
    # business_rel
    for c in group1_cust:
        business_rel[(group1_prov, c)] = prov2cust
        business_rel[(c, group1_prov)] = cust2prov

    # group 2
    group2_prov = 10
    group2_cust = list(range(11, 15))

    edges[group2_prov].extend(group2_cust)
    for c in group2_cust:
        edges[c].append(group2_prov)
    # business_rel
    for c in group2_cust:
        business_rel[(group2_prov, c)] = prov2cust
        business_rel[(c, group2_prov)] = cust2prov

    # group 3
    group3_prov = 15
    group3_cust = list(range(16, 20))

    edges[group3_prov].extend(group3_cust)
    for c in group3_cust:
        edges[c].append(group3_prov)
    # business_rel
    for c in group3_cust:
        business_rel[(group3_prov, c)] = prov2cust
        business_rel[(c, group3_prov)] = cust2prov

    # group 4
    group4_prov = 20
    group4_cust = list(range(21, 26))

    edges[group4_prov].extend(group4_cust)
    for c in group4_cust:
        edges[c].append(group4_prov)
    # business_rel
    for c in group4_cust:
        business_rel[(group4_prov, c)] = prov2cust
        business_rel[(c, group4_prov)] = cust2prov

    # group 5
    group5_prov = 26
    group5_cust = list(range(27, 31))

    edges[group5_prov].extend(group5_cust)
    for c in group5_cust:
        edges[c].append(group5_prov)
    # business_rel
    for c in group5_cust:
        business_rel[(group5_prov, c)] = prov2cust
        business_rel[(c, group5_prov)] = cust2prov

    # group 6
    group6_prov = 31
    group6_cust = list(range(32, 36)) + [30]

    edges[group6_prov].extend(group6_cust)
    for c in group6_cust:
        edges[c].append(group6_prov)
    # business_rel
    for c in group6_cust:
        business_rel[(group6_prov, c)] = prov2cust
        business_rel[(c, group6_prov)] = cust2prov

    # group 7
    group7_prov = 36
    group7_cust = list(range(37, 40)) + [35]

    edges[group7_prov].extend(group7_cust)
    for c in group7_cust:
        edges[c].append(group7_prov)
    # business_rel
    for c in group7_cust:
        business_rel[(group7_prov, c)] = prov2cust
        business_rel[(c, group7_prov)] = cust2prov

    # edges between groups
    # providers of groups 2 - 6 are customers of group 1 prov
    edges[group2_prov].append(group1_prov)
    edges[group1_prov].append(group2_prov)
    business_rel[(group1_prov, group2_prov)] = prov2cust
    business_rel[(group2_prov, group1_prov)] = cust2prov

    edges[group3_prov].append(group1_prov)
    edges[group1_prov].append(group3_prov)
    business_rel[(group1_prov, group3_prov)] = prov2cust
    business_rel[(group3_prov, group1_prov)] = cust2prov

    edges[group4_prov].append(group1_prov)
    edges[group1_prov].append(group4_prov)
    business_rel[(group1_prov, group4_prov)] = prov2cust
    business_rel[(group4_prov, group1_prov)] = cust2prov

    edges[group5_prov].append(group1_prov)
    edges[group1_prov].append(group5_prov)
    business_rel[(group1_prov, group5_prov)] = prov2cust
    business_rel[(group5_prov, group1_prov)] = cust2prov

    edges[group6_prov].append(group1_prov)
    edges[group1_prov].append(group6_prov)
    business_rel[(group1_prov, group6_prov)] = prov2cust
    business_rel[(group6_prov, group1_prov)] = cust2prov

    edges[group7_prov].append(
        9
    )  # group 7's prov is a customer of 10, who is a customer of group1_prov
    edges[9].append(group7_prov)
    business_rel[group7_prov, 9] = cust2prov
    business_rel[9, group7_prov] = prov2cust

    # peering edges between providers of groups 2 - 3, 3 - 4, 4 - 5

    # 2 - 3
    edges[group2_prov].append(group3_prov)
    edges[group3_prov].append(group2_prov)
    # p2p
    business_rel[(group2_prov, group3_prov)] = p2p
    business_rel[(group3_prov, group2_prov)] = p2p

    # 3 - 4
    edges[group3_prov].append(group4_prov)
    edges[group4_prov].append(group3_prov)
    # p2p
    business_rel[(group3_prov, group4_prov)] = p2p
    business_rel[(group4_prov, group3_prov)] = p2p

    # 4 - 5
    edges[group4_prov].append(group5_prov)
    edges[group5_prov].append(group4_prov)
    # p2p
    business_rel[(group4_prov, group5_prov)] = p2p
    business_rel[(group5_prov, group4_prov)] = p2p

    edge_list = [(u, v) for (u, vs) in edges.items() for v in vs]
    return len(nodes), edge_list, business_rel


def nv_comment(s):
    return "(* " + s + " *)"


def pattern(x):
    if isinstance(x, tuple) and len(x) == 2:
        return f"{x[0]}~{x[1]}"
    else:
        return str(x)


def dict_to_match(d, exp):
    branches = "\n".join([f"| {pattern(pat)} -> {body}" for (pat, body) in d.items()])
    return f"match {exp} with\n{branches}"


def to_nv(nodes, edges, business_rel):
    """
    Convert to an NV file
    """
    f = NvFile("roedunet.nv")
    f.add_type("bgpType", "{bgpAd: int; lp: int; aslen: int; med:int; comms:set[int];}")
    f.add_type("attribute", "option[bgpType]")

    f.add_topology(nodes, edges)
    relp_body = dict_to_match(business_rel, "e")
    f.add_let("cust_prov", [], 0)
    f.add_let("peer_peer", [], 1)
    f.add_let("prov_cust", [], 2)
    f.add_let("relationship", ["e"], relp_body)

    f.funcs.append(
        r"""let init n = match n with
  | 2n -> Some { bgpAd = 0; lp = 100; aslen = 0; med = 0; comms = {} }
  | _ -> None"""
    )

    f.funcs.append(
        r"""let pickOption f x y =
  match (x,y) with
  | (None, None) -> None
  | (None, Some _) -> y  | (Some _, None) -> x
  | (Some a, Some b) -> Some (f a b)

let betterBgp b1 b2 =
  if b1.lp > b2.lp then b1
  else if b2.lp > b1.lp then b2
  else if b1.aslen < b2.aslen then b1
  else if b2.aslen < b1.aslen then b2  else if b1.med >= b2.med then b1 else b2

let mergeBgp x y = pickOption betterBgp x y

let merge n x y = mergeBgp x y"""
    )
    f.funcs.append(
        r"""(* We add community tags to designate providers, peers and customers,
 * and use these tags to adjust local preference.
 * We also need to identify when an edge is to a provider or a peer,
 * in which case if the route is tagged as from a customer then it
 * should be dropped.
 * The relationship(a~b) edge function returns:
 * - cust_prov if a is a customer of b (b is a provider for a)
 * - peer_peer if a is a peer of b (should be symmetric)
 * - prov_cust if a is a provider for b (b is a customer of a)
 * A node v will only advertise a route from its neighbor u to another neighbor w according to the following rules:
 * if relationship(uv) = customer, v will advertise the route to w;
 * if relationship(uv) = peer or relationship(uv) = prov, v will only advertise the route to w if relationship(vw) = cust
 *)
let transferBgp e x =
  match x with
  | None -> None
  | Some b -> (
    (* enforce no transit: if the route is neither from a customer nor to a customer, then drop it;
     * don't use !(b.comms[cust_prov]) since by default b.comms starts empty
     *)
    if (b.comms[peer_peer] || b.comms[prov_cust]) && !(relationship e = prov_cust) then None else
    (* update LP *)
    let lp = if (relationship e = cust_prov) then 200
        else if (relationship e = peer_peer) then 100
        else 0
    in
    (* update comms: mark the source of the message and remove old relationship tags *)
    let comms = if (relationship e = cust_prov) then b.comms[cust_prov := true][peer_peer := false][prov_cust := false]
        else if (relationship e = peer_peer) then b.comms[peer_peer := true][cust_prov := false][prov_cust := false]
        else b.comms[prov_cust := true][cust_prov := false][peer_peer := false]
    in
    let b = {b with comms = comms; aslen = b.aslen + 1; lp = lp} in
    Some b
)

let trans e x = transferBgp e x"""
    )
    f.add_let("assert_node", ["u", "v"], "match v with | None -> false | _ -> true")
    f.add_solution("sol")
    f.add_assert("foldNodes (fun u v acc -> acc && assert_node u v) sol true")
    return str(f)


def to_hgr(nodes, edges):
    com = f"% generated from {os.path.basename(__file__)}\n% number of edges; number of vertices\n% note vertex numbering starts from 1, so 0 is remapped to {nodes}"
    # remap 0 to the max node to start numbering from 1
    edges = [(u if u > 0 else nodes, v if v > 0 else nodes) for (u, v) in edges]
    edge_list = "\n".join([f"{u} {v}" for (u, v) in edges])
    return com + f"\n{len(edges)} {nodes}\n" + edge_list


if __name__ == "__main__":
    nodes, edges, business_rel = RoEduNet()
    if sys.argv[1] == "nv":
        print(to_nv(nodes, edges, business_rel))
    elif sys.argv[1] == "hgr":
        print(to_hgr(nodes, edges))
