(* vim: set syntax=ocaml: *)
(* hMETIS-partitioned version of RoEduNet.nv with 40 partitions *)
(* Automatically generated by gen_part_nv.py *)
(* Generated by roedunet.py *)

type bgpType = {bgpAd: int; lp: int; aslen: int; med:int; comms:set[int];}

type attribute = option[bgpType]

let nodes = 40

let edges = {
  0-1;
  0-2;
  0-3;
  0-4;
  0-5;
  0-6;
  0-7;
  0-8;
  0-9;
  0-10;
  0-15;
  0-20;
  0-26;
  0-31;
  1-0;
  2-0;
  3-0;
  4-0;
  5-0;
  6-0;
  7-0;
  8-0;
  9-0;
  9-36;
  10-11;
  10-12;
  10-13;
  10-14;
  10-0;
  10-15;
  11-10;
  12-10;
  13-10;
  14-10;
  15-16;
  15-17;
  15-18;
  15-19;
  15-0;
  15-10;
  15-20;
  16-15;
  17-15;
  18-15;
  19-15;
  20-21;
  20-22;
  20-23;
  20-24;
  20-25;
  20-0;
  20-15;
  20-26;
  21-20;
  22-20;
  23-20;
  24-20;
  25-20;
  26-27;
  26-28;
  26-29;
  26-30;
  26-0;
  26-20;
  27-26;
  28-26;
  29-26;
  30-26;
  30-31;
  31-32;
  31-33;
  31-34;
  31-35;
  31-30;
  31-0;
  32-31;
  33-31;
  34-31;
  35-31;
  35-36;
  36-37;
  36-38;
  36-39;
  36-35;
  36-9;
  37-36;
  38-36;
  39-36;
}

let cust_prov = 0

let peer_peer = 1

let prov_cust = 2

let relationship e = match e with
| 0~1 -> prov_cust
| 1~0 -> cust_prov
| 0~2 -> prov_cust
| 2~0 -> cust_prov
| 0~3 -> prov_cust
| 3~0 -> cust_prov
| 0~4 -> prov_cust
| 4~0 -> cust_prov
| 0~5 -> prov_cust
| 5~0 -> cust_prov
| 0~6 -> prov_cust
| 6~0 -> cust_prov
| 0~7 -> prov_cust
| 7~0 -> cust_prov
| 0~8 -> prov_cust
| 8~0 -> cust_prov
| 0~9 -> prov_cust
| 9~0 -> cust_prov
| 10~11 -> prov_cust
| 11~10 -> cust_prov
| 10~12 -> prov_cust
| 12~10 -> cust_prov
| 10~13 -> prov_cust
| 13~10 -> cust_prov
| 10~14 -> prov_cust
| 14~10 -> cust_prov
| 15~16 -> prov_cust
| 16~15 -> cust_prov
| 15~17 -> prov_cust
| 17~15 -> cust_prov
| 15~18 -> prov_cust
| 18~15 -> cust_prov
| 15~19 -> prov_cust
| 19~15 -> cust_prov
| 20~21 -> prov_cust
| 21~20 -> cust_prov
| 20~22 -> prov_cust
| 22~20 -> cust_prov
| 20~23 -> prov_cust
| 23~20 -> cust_prov
| 20~24 -> prov_cust
| 24~20 -> cust_prov
| 20~25 -> prov_cust
| 25~20 -> cust_prov
| 26~27 -> prov_cust
| 27~26 -> cust_prov
| 26~28 -> prov_cust
| 28~26 -> cust_prov
| 26~29 -> prov_cust
| 29~26 -> cust_prov
| 26~30 -> prov_cust
| 30~26 -> cust_prov
| 31~32 -> prov_cust
| 32~31 -> cust_prov
| 31~33 -> prov_cust
| 33~31 -> cust_prov
| 31~34 -> prov_cust
| 34~31 -> cust_prov
| 31~35 -> prov_cust
| 35~31 -> cust_prov
| 31~30 -> prov_cust
| 30~31 -> cust_prov
| 36~37 -> prov_cust
| 37~36 -> cust_prov
| 36~38 -> prov_cust
| 38~36 -> cust_prov
| 36~39 -> prov_cust
| 39~36 -> cust_prov
| 36~35 -> prov_cust
| 35~36 -> cust_prov
| 0~10 -> prov_cust
| 10~0 -> cust_prov
| 0~15 -> prov_cust
| 15~0 -> cust_prov
| 0~20 -> prov_cust
| 20~0 -> cust_prov
| 0~26 -> prov_cust
| 26~0 -> cust_prov
| 0~31 -> prov_cust
| 31~0 -> cust_prov
| 36~9 -> cust_prov
| 9~36 -> prov_cust
| 10~15 -> peer_peer
| 15~10 -> peer_peer
| 15~20 -> peer_peer
| 20~15 -> peer_peer
| 20~26 -> peer_peer
| 26~20 -> peer_peer

let init n = match n with
  | 2n -> Some { bgpAd = 0; lp = 100; aslen = 0; med = 0; comms = {} }
  | _ -> None

let pickOption f x y =
  match (x,y) with
  | (None, None) -> None
  | (None, Some _) -> y  | (Some _, None) -> x
  | (Some a, Some b) -> Some (f a b)

let betterBgp b1 b2 =
  if b1.lp > b2.lp then b1
  else if b2.lp > b1.lp then b2
  else if b1.aslen < b2.aslen then b1
  else if b2.aslen < b1.aslen then b2  else if b1.med >= b2.med then b1 else b2

let mergeBgp x y = pickOption betterBgp x y

let merge n x y = mergeBgp x y

(* We add community tags to designate providers, peers and customers,
 * and use these tags to adjust local preference.
 * We also need to identify when an edge is to a provider or a peer,
 * in which case if the route is tagged as from a customer then it
 * should be dropped.
 * The relationship(a~b) edge function returns:
 * - cust_prov if a is a customer of b (b is a provider for a)
 * - peer_peer if a is a peer of b (should be symmetric)
 * - prov_cust if a is a provider for b (b is a customer of a)
 * A node v will only advertise a route from its neighbor u to another neighbor w according to the following rules:
 * if relationship(uv) = customer, v will advertise the route to w;
 * if relationship(uv) = peer or relationship(uv) = prov, v will only advertise the route to w if relationship(vw) = cust
 *)
let transferBgp e x =
  match x with
  | None -> None
  | Some b -> (
    (* enforce no transit: if the route is neither from a customer nor to a customer, then drop it;
     * don't use !(b.comms[cust_prov]) since by default b.comms starts empty
     *)
    if (b.comms[peer_peer] || b.comms[prov_cust]) && !(relationship e = prov_cust) then None else
    (* update LP *)
    let lp = if (relationship e = cust_prov) then 200
        else if (relationship e = peer_peer) then 100
        else 0
    in
    (* update comms: mark the source of the message and remove old relationship tags *)
    let comms = if (relationship e = cust_prov) then b.comms[cust_prov := true][peer_peer := false][prov_cust := false]
        else if (relationship e = peer_peer) then b.comms[peer_peer := true][cust_prov := false][prov_cust := false]
        else b.comms[prov_cust := true][cust_prov := false][peer_peer := false]
    in
    let b = {b with comms = comms; aslen = b.aslen + 1; lp = lp} in
    Some b
)

let trans e x = transferBgp e x

let assert_node u v = match v with | None -> false | _ -> true

let sol = solution { init = init; trans = trans; merge = merge; interface = interface; rtrans = trans }

assert foldNodes (fun u v acc -> acc && assert_node u v) sol true

let partition node = match node with
  | 1n -> 0
  | 2n -> 1
  | 3n -> 2
  | 4n -> 3
  | 5n -> 4
  | 6n -> 5
  | 7n -> 6
  | 8n -> 7
  | 9n -> 8
  | 10n -> 9
  | 11n -> 10
  | 12n -> 11
  | 13n -> 12
  | 14n -> 13
  | 15n -> 14
  | 16n -> 15
  | 17n -> 16
  | 18n -> 17
  | 19n -> 18
  | 20n -> 19
  | 21n -> 20
  | 22n -> 21
  | 23n -> 22
  | 24n -> 23
  | 25n -> 24
  | 26n -> 25
  | 27n -> 26
  | 28n -> 27
  | 29n -> 28
  | 30n -> 29
  | 31n -> 30
  | 32n -> 31
  | 33n -> 32
  | 34n -> 33
  | 35n -> 34
  | 36n -> 35
  | 37n -> 36
  | 38n -> 37
  | 39n -> 38
  | 0n -> 39

let interface edge a =
  match edge with
  | 0~1 -> a = Some {  aslen= 1u32; bgpAd= 0u32; comms= { 0u32 |-> true ; _ |-> false}; lp= 200u32; med= 0u32; }
  | 0~2 -> a = Some {  aslen= 1u32; bgpAd= 0u32; comms= { 0u32 |-> true ; _ |-> false}; lp= 200u32; med= 0u32; }
  | 0~3 -> a = Some {  aslen= 1u32; bgpAd= 0u32; comms= { 0u32 |-> true ; _ |-> false}; lp= 200u32; med= 0u32; }
  | 0~4 -> a = Some {  aslen= 1u32; bgpAd= 0u32; comms= { 0u32 |-> true ; _ |-> false}; lp= 200u32; med= 0u32; }
  | 0~5 -> a = Some {  aslen= 1u32; bgpAd= 0u32; comms= { 0u32 |-> true ; _ |-> false}; lp= 200u32; med= 0u32; }
  | 0~6 -> a = Some {  aslen= 1u32; bgpAd= 0u32; comms= { 0u32 |-> true ; _ |-> false}; lp= 200u32; med= 0u32; }
  | 0~7 -> a = Some {  aslen= 1u32; bgpAd= 0u32; comms= { 0u32 |-> true ; _ |-> false}; lp= 200u32; med= 0u32; }
  | 0~8 -> a = Some {  aslen= 1u32; bgpAd= 0u32; comms= { 0u32 |-> true ; _ |-> false}; lp= 200u32; med= 0u32; }
  | 0~9 -> a = Some {  aslen= 1u32; bgpAd= 0u32; comms= { 0u32 |-> true ; _ |-> false}; lp= 200u32; med= 0u32; }
  | 0~10 -> a = Some {  aslen= 1u32; bgpAd= 0u32; comms= { 0u32 |-> true ; _ |-> false}; lp= 200u32; med= 0u32; }
  | 0~15 -> a = Some {  aslen= 1u32; bgpAd= 0u32; comms= { 0u32 |-> true ; _ |-> false}; lp= 200u32; med= 0u32; }
  | 0~20 -> a = Some {  aslen= 1u32; bgpAd= 0u32; comms= { 0u32 |-> true ; _ |-> false}; lp= 200u32; med= 0u32; }
  | 0~26 -> a = Some {  aslen= 1u32; bgpAd= 0u32; comms= { 0u32 |-> true ; _ |-> false}; lp= 200u32; med= 0u32; }
  | 0~31 -> a = Some {  aslen= 1u32; bgpAd= 0u32; comms= { 0u32 |-> true ; _ |-> false}; lp= 200u32; med= 0u32; }
  | 1~0 -> a = Some {  aslen= 2u32; bgpAd= 0u32; comms= { 2u32 |-> true ; _ |-> false}; lp= 0u32; med= 0u32; }
  | 2~0 -> a = Some {  aslen= 0u32; bgpAd= 0u32; comms= { _ |-> false }; lp= 100u32; med= 0u32; }
  | 3~0 -> a = Some {  aslen= 2u32; bgpAd= 0u32; comms= { 2u32 |-> true ; _ |-> false}; lp= 0u32; med= 0u32; }
  | 4~0 -> a = Some {  aslen= 2u32; bgpAd= 0u32; comms= { 2u32 |-> true ; _ |-> false}; lp= 0u32; med= 0u32; }
  | 5~0 -> a = Some {  aslen= 2u32; bgpAd= 0u32; comms= { 2u32 |-> true ; _ |-> false}; lp= 0u32; med= 0u32; }
  | 6~0 -> a = Some {  aslen= 2u32; bgpAd= 0u32; comms= { 2u32 |-> true ; _ |-> false}; lp= 0u32; med= 0u32; }
  | 7~0 -> a = Some {  aslen= 2u32; bgpAd= 0u32; comms= { 2u32 |-> true ; _ |-> false}; lp= 0u32; med= 0u32; }
  | 8~0 -> a = Some {  aslen= 2u32; bgpAd= 0u32; comms= { 2u32 |-> true ; _ |-> false}; lp= 0u32; med= 0u32; }
  | 9~0 -> a = Some {  aslen= 2u32; bgpAd= 0u32; comms= { 2u32 |-> true ; _ |-> false}; lp= 0u32; med= 0u32; }
  | 9~36 -> a = Some {  aslen= 2u32; bgpAd= 0u32; comms= { 2u32 |-> true ; _ |-> false}; lp= 0u32; med= 0u32; }
  | 10~0 -> a = Some {  aslen= 2u32; bgpAd= 0u32; comms= { 2u32 |-> true ; _ |-> false}; lp= 0u32; med= 0u32; }
  | 10~11 -> a = Some {  aslen= 2u32; bgpAd= 0u32; comms= { 2u32 |-> true ; _ |-> false}; lp= 0u32; med= 0u32; }
  | 10~12 -> a = Some {  aslen= 2u32; bgpAd= 0u32; comms= { 2u32 |-> true ; _ |-> false}; lp= 0u32; med= 0u32; }
  | 10~13 -> a = Some {  aslen= 2u32; bgpAd= 0u32; comms= { 2u32 |-> true ; _ |-> false}; lp= 0u32; med= 0u32; }
  | 10~14 -> a = Some {  aslen= 2u32; bgpAd= 0u32; comms= { 2u32 |-> true ; _ |-> false}; lp= 0u32; med= 0u32; }
  | 10~15 -> a = Some {  aslen= 2u32; bgpAd= 0u32; comms= { 2u32 |-> true ; _ |-> false}; lp= 0u32; med= 0u32; }
  | 11~10 -> a = Some {  aslen= 3u32; bgpAd= 0u32; comms= { 2u32 |-> true ; _ |-> false}; lp= 0u32; med= 0u32; }
  | 12~10 -> a = Some {  aslen= 3u32; bgpAd= 0u32; comms= { 2u32 |-> true ; _ |-> false}; lp= 0u32; med= 0u32; }
  | 13~10 -> a = Some {  aslen= 3u32; bgpAd= 0u32; comms= { 2u32 |-> true ; _ |-> false}; lp= 0u32; med= 0u32; }
  | 14~10 -> a = Some {  aslen= 3u32; bgpAd= 0u32; comms= { 2u32 |-> true ; _ |-> false}; lp= 0u32; med= 0u32; }
  | 15~0 -> a = Some {  aslen= 2u32; bgpAd= 0u32; comms= { 2u32 |-> true ; _ |-> false}; lp= 0u32; med= 0u32; }
  | 15~10 -> a = Some {  aslen= 2u32; bgpAd= 0u32; comms= { 2u32 |-> true ; _ |-> false}; lp= 0u32; med= 0u32; }
  | 15~16 -> a = Some {  aslen= 2u32; bgpAd= 0u32; comms= { 2u32 |-> true ; _ |-> false}; lp= 0u32; med= 0u32; }
  | 15~17 -> a = Some {  aslen= 2u32; bgpAd= 0u32; comms= { 2u32 |-> true ; _ |-> false}; lp= 0u32; med= 0u32; }
  | 15~18 -> a = Some {  aslen= 2u32; bgpAd= 0u32; comms= { 2u32 |-> true ; _ |-> false}; lp= 0u32; med= 0u32; }
  | 15~19 -> a = Some {  aslen= 2u32; bgpAd= 0u32; comms= { 2u32 |-> true ; _ |-> false}; lp= 0u32; med= 0u32; }
  | 15~20 -> a = Some {  aslen= 2u32; bgpAd= 0u32; comms= { 2u32 |-> true ; _ |-> false}; lp= 0u32; med= 0u32; }
  | 16~15 -> a = Some {  aslen= 3u32; bgpAd= 0u32; comms= { 2u32 |-> true ; _ |-> false}; lp= 0u32; med= 0u32; }
  | 17~15 -> a = Some {  aslen= 3u32; bgpAd= 0u32; comms= { 2u32 |-> true ; _ |-> false}; lp= 0u32; med= 0u32; }
  | 18~15 -> a = Some {  aslen= 3u32; bgpAd= 0u32; comms= { 2u32 |-> true ; _ |-> false}; lp= 0u32; med= 0u32; }
  | 19~15 -> a = Some {  aslen= 3u32; bgpAd= 0u32; comms= { 2u32 |-> true ; _ |-> false}; lp= 0u32; med= 0u32; }
  | 20~0 -> a = Some {  aslen= 2u32; bgpAd= 0u32; comms= { 2u32 |-> true ; _ |-> false}; lp= 0u32; med= 0u32; }
  | 20~15 -> a = Some {  aslen= 2u32; bgpAd= 0u32; comms= { 2u32 |-> true ; _ |-> false}; lp= 0u32; med= 0u32; }
  | 20~21 -> a = Some {  aslen= 2u32; bgpAd= 0u32; comms= { 2u32 |-> true ; _ |-> false}; lp= 0u32; med= 0u32; }
  | 20~22 -> a = Some {  aslen= 2u32; bgpAd= 0u32; comms= { 2u32 |-> true ; _ |-> false}; lp= 0u32; med= 0u32; }
  | 20~23 -> a = Some {  aslen= 2u32; bgpAd= 0u32; comms= { 2u32 |-> true ; _ |-> false}; lp= 0u32; med= 0u32; }
  | 20~24 -> a = Some {  aslen= 2u32; bgpAd= 0u32; comms= { 2u32 |-> true ; _ |-> false}; lp= 0u32; med= 0u32; }
  | 20~25 -> a = Some {  aslen= 2u32; bgpAd= 0u32; comms= { 2u32 |-> true ; _ |-> false}; lp= 0u32; med= 0u32; }
  | 20~26 -> a = Some {  aslen= 2u32; bgpAd= 0u32; comms= { 2u32 |-> true ; _ |-> false}; lp= 0u32; med= 0u32; }
  | 21~20 -> a = Some {  aslen= 3u32; bgpAd= 0u32; comms= { 2u32 |-> true ; _ |-> false}; lp= 0u32; med= 0u32; }
  | 22~20 -> a = Some {  aslen= 3u32; bgpAd= 0u32; comms= { 2u32 |-> true ; _ |-> false}; lp= 0u32; med= 0u32; }
  | 23~20 -> a = Some {  aslen= 3u32; bgpAd= 0u32; comms= { 2u32 |-> true ; _ |-> false}; lp= 0u32; med= 0u32; }
  | 24~20 -> a = Some {  aslen= 3u32; bgpAd= 0u32; comms= { 2u32 |-> true ; _ |-> false}; lp= 0u32; med= 0u32; }
  | 25~20 -> a = Some {  aslen= 3u32; bgpAd= 0u32; comms= { 2u32 |-> true ; _ |-> false}; lp= 0u32; med= 0u32; }
  | 26~0 -> a = Some {  aslen= 2u32; bgpAd= 0u32; comms= { 2u32 |-> true ; _ |-> false}; lp= 0u32; med= 0u32; }
  | 26~20 -> a = Some {  aslen= 2u32; bgpAd= 0u32; comms= { 2u32 |-> true ; _ |-> false}; lp= 0u32; med= 0u32; }
  | 26~27 -> a = Some {  aslen= 2u32; bgpAd= 0u32; comms= { 2u32 |-> true ; _ |-> false}; lp= 0u32; med= 0u32; }
  | 26~28 -> a = Some {  aslen= 2u32; bgpAd= 0u32; comms= { 2u32 |-> true ; _ |-> false}; lp= 0u32; med= 0u32; }
  | 26~29 -> a = Some {  aslen= 2u32; bgpAd= 0u32; comms= { 2u32 |-> true ; _ |-> false}; lp= 0u32; med= 0u32; }
  | 26~30 -> a = Some {  aslen= 2u32; bgpAd= 0u32; comms= { 2u32 |-> true ; _ |-> false}; lp= 0u32; med= 0u32; }
  | 27~26 -> a = Some {  aslen= 3u32; bgpAd= 0u32; comms= { 2u32 |-> true ; _ |-> false}; lp= 0u32; med= 0u32; }
  | 28~26 -> a = Some {  aslen= 3u32; bgpAd= 0u32; comms= { 2u32 |-> true ; _ |-> false}; lp= 0u32; med= 0u32; }
  | 29~26 -> a = Some {  aslen= 3u32; bgpAd= 0u32; comms= { 2u32 |-> true ; _ |-> false}; lp= 0u32; med= 0u32; }
  | 30~26 -> a = Some {  aslen= 3u32; bgpAd= 0u32; comms= { 2u32 |-> true ; _ |-> false}; lp= 0u32; med= 0u32; }
  | 30~31 -> a = Some {  aslen= 3u32; bgpAd= 0u32; comms= { 2u32 |-> true ; _ |-> false}; lp= 0u32; med= 0u32; }
  | 31~0 -> a = Some {  aslen= 2u32; bgpAd= 0u32; comms= { 2u32 |-> true ; _ |-> false}; lp= 0u32; med= 0u32; }
  | 31~30 -> a = Some {  aslen= 2u32; bgpAd= 0u32; comms= { 2u32 |-> true ; _ |-> false}; lp= 0u32; med= 0u32; }
  | 31~32 -> a = Some {  aslen= 2u32; bgpAd= 0u32; comms= { 2u32 |-> true ; _ |-> false}; lp= 0u32; med= 0u32; }
  | 31~33 -> a = Some {  aslen= 2u32; bgpAd= 0u32; comms= { 2u32 |-> true ; _ |-> false}; lp= 0u32; med= 0u32; }
  | 31~34 -> a = Some {  aslen= 2u32; bgpAd= 0u32; comms= { 2u32 |-> true ; _ |-> false}; lp= 0u32; med= 0u32; }
  | 31~35 -> a = Some {  aslen= 2u32; bgpAd= 0u32; comms= { 2u32 |-> true ; _ |-> false}; lp= 0u32; med= 0u32; }
  | 32~31 -> a = Some {  aslen= 3u32; bgpAd= 0u32; comms= { 2u32 |-> true ; _ |-> false}; lp= 0u32; med= 0u32; }
  | 33~31 -> a = Some {  aslen= 3u32; bgpAd= 0u32; comms= { 2u32 |-> true ; _ |-> false}; lp= 0u32; med= 0u32; }
  | 34~31 -> a = Some {  aslen= 3u32; bgpAd= 0u32; comms= { 2u32 |-> true ; _ |-> false}; lp= 0u32; med= 0u32; }
  | 35~31 -> a = Some {  aslen= 3u32; bgpAd= 0u32; comms= { 2u32 |-> true ; _ |-> false}; lp= 0u32; med= 0u32; }
  | 35~36 -> a = Some {  aslen= 3u32; bgpAd= 0u32; comms= { 2u32 |-> true ; _ |-> false}; lp= 0u32; med= 0u32; }
  | 36~9 -> a = Some {  aslen= 3u32; bgpAd= 0u32; comms= { 2u32 |-> true ; _ |-> false}; lp= 0u32; med= 0u32; }
  | 36~35 -> a = Some {  aslen= 3u32; bgpAd= 0u32; comms= { 2u32 |-> true ; _ |-> false}; lp= 0u32; med= 0u32; }
  | 36~37 -> a = Some {  aslen= 3u32; bgpAd= 0u32; comms= { 2u32 |-> true ; _ |-> false}; lp= 0u32; med= 0u32; }
  | 36~38 -> a = Some {  aslen= 3u32; bgpAd= 0u32; comms= { 2u32 |-> true ; _ |-> false}; lp= 0u32; med= 0u32; }
  | 36~39 -> a = Some {  aslen= 3u32; bgpAd= 0u32; comms= { 2u32 |-> true ; _ |-> false}; lp= 0u32; med= 0u32; }
  | 37~36 -> a = Some {  aslen= 4u32; bgpAd= 0u32; comms= { 2u32 |-> true ; _ |-> false}; lp= 0u32; med= 0u32; }
  | 38~36 -> a = Some {  aslen= 4u32; bgpAd= 0u32; comms= { 2u32 |-> true ; _ |-> false}; lp= 0u32; med= 0u32; }
  | 39~36 -> a = Some {  aslen= 4u32; bgpAd= 0u32; comms= { 2u32 |-> true ; _ |-> false}; lp= 0u32; med= 0u32; }
