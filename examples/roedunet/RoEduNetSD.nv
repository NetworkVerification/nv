(* Generated by roedunet.py *)

type bgpType = {bgpAd: int; lp: int; aslen: int; med:int; comms:set[int];}

type attribute = option[bgpType]

let nodes = 41

let edges = {
  32=14; (*Dolj <--> Olt*)
  32=38; (*Dolj <--> Gorj*)
  32=7; (*Dolj <--> Valcea*)
  32=37; (*Dolj <--> Mehedinti*)
  32=33; (*Dolj <--> Timis*)
  17=6; (*Bucaresti <--> Cluj*)
  17=10; (*Bucaresti <--> Ialomita*)
  17=16; (*Bucaresti <--> Teleorman*)
  17=27; (*Bucaresti <--> Giurgiu*)
  17=19; (*Bucaresti <--> Calarasi*)
  17=39; (*Bucaresti <--> Constanta*)
  17=30; (*Bucaresti <--> Dambovita*)
  17=18; (*Bucaresti <--> Prahova*)
  17=12; (*Bucaresti <--> Buzau*)
  17=33; (*Bucaresti <--> Timis*)
  17=4; (*Bucaresti <--> Mures*)
  17=34; (*Bucaresti <--> Galati*)
  17=1; (*Bucaresti <--> Iasi*)
  8=4; (*Covasna <--> Mures*)
  22=6; (*Alba <--> Cluj*)
  9=1; (*Bacau <--> Iasi*)
  13=4; (*Harghita <--> Mures*)
  0=1; (*Chisinau RENAM <--> Iasi*)
  40=6; (*Bistrita-Nasaud <--> Cluj*)
  34=21; (*Galati <--> Tulcea*)
  34=1; (*Galati <--> Iasi*)
  24=1; (*Botosani <--> Iasi*)
  36=33; (*Caras-Severin <--> Timis*)
  6=25; (*Cluj <--> Salaj*)
  6=33; (*Cluj <--> Timis*)
  5=33; (*Bihor <--> Timis*)
  2=33; (*Arad <--> Timis*)
  17=32; (*Bucaresti <--> Dolj*)
  28=17; (*Arges <--> Bucaresti*)
  26=33; (*Hunedora <--> Timis*)
  6=3; (*Cluj <--> Satu Mare*)
  6=29; (*Cluj <--> Maramures*)
  4=35; (*Mures <--> Sibiu*)
  1=20; (*Iasi <--> Vaslui*)
  1=11; (*Iasi <--> Neamt*)
  1=23; (*Iasi <--> Suceava*)
  34=31; (*Galati <--> Vrancea*)
  15=34; (*Braila <--> Galati*)
  6=4; (*Cluj <--> Mures*)
  1=4; (*Iasi <--> Mures*)
}

let cust_prov = 0

let peer_peer = 1

let prov_cust = 2

symbolic d : int

require d = 0 || d = 2 || d = 3 || d = 5 || d = 7 || d = 8 || d = 9 || d = 10 || d = 11 || d = 12 || d = 13 || d = 14 || d = 15 || d = 16 || d = 18 || d = 19 || d = 20 || d = 21 || d = 22 || d = 23 || d = 24 || d = 25 || d = 26 || d = 27 || d = 28 || d = 29 || d = 30 || d = 31 || d = 35 || d = 36 || d = 37 || d = 38 || d = 39 || d = 40

require d < 41

let node_to_int n = match n with
| 0n -> 0
| 1n -> 1
| 2n -> 2
| 3n -> 3
| 4n -> 4
| 5n -> 5
| 6n -> 6
| 7n -> 7
| 8n -> 8
| 9n -> 9
| 10n -> 10
| 11n -> 11
| 12n -> 12
| 13n -> 13
| 14n -> 14
| 15n -> 15
| 16n -> 16
| 17n -> 17
| 18n -> 18
| 19n -> 19
| 20n -> 20
| 21n -> 21
| 22n -> 22
| 23n -> 23
| 24n -> 24
| 25n -> 25
| 26n -> 26
| 27n -> 27
| 28n -> 28
| 29n -> 29
| 30n -> 30
| 31n -> 31
| 32n -> 32
| 33n -> 33
| 34n -> 34
| 35n -> 35
| 36n -> 36
| 37n -> 37
| 38n -> 38
| 39n -> 39
| 40n -> 40

let relationship e = match e with
| 32~14 -> prov_cust
| 32~38 -> prov_cust
| 32~7 -> prov_cust
| 32~17 -> cust_prov
| 32~37 -> prov_cust
| 32~33 -> peer_peer
| 17~6 -> prov_cust
| 17~10 -> prov_cust
| 17~16 -> prov_cust
| 17~27 -> prov_cust
| 17~19 -> prov_cust
| 17~39 -> prov_cust
| 17~28 -> prov_cust
| 17~30 -> prov_cust
| 17~18 -> prov_cust
| 17~12 -> prov_cust
| 17~33 -> prov_cust
| 17~4 -> prov_cust
| 17~34 -> prov_cust
| 17~1 -> prov_cust
| 8~4 -> cust_prov
| 35~4 -> cust_prov
| 22~6 -> cust_prov
| 31~34 -> cust_prov
| 9~1 -> cust_prov
| 13~4 -> cust_prov
| 0~1 -> cust_prov
| 4~6 -> peer_peer
| 4~1 -> peer_peer
| 40~6 -> cust_prov
| 20~1 -> cust_prov
| 34~21 -> prov_cust
| 34~15 -> prov_cust
| 34~1 -> peer_peer
| 11~1 -> cust_prov
| 23~1 -> cust_prov
| 24~1 -> cust_prov
| 36~33 -> cust_prov
| 3~6 -> cust_prov
| 29~6 -> cust_prov
| 6~25 -> prov_cust
| 6~33 -> peer_peer
| 5~33 -> cust_prov
| 2~33 -> cust_prov
| 33~26 -> prov_cust
| 17~32 -> prov_cust
| 6~17 -> cust_prov
| 10~17 -> cust_prov
| 16~17 -> cust_prov
| 27~17 -> cust_prov
| 19~17 -> cust_prov
| 39~17 -> cust_prov
| 28~17 -> cust_prov
| 30~17 -> cust_prov
| 18~17 -> cust_prov
| 12~17 -> cust_prov
| 33~17 -> cust_prov
| 4~17 -> cust_prov
| 34~17 -> cust_prov
| 1~17 -> cust_prov
| 14~32 -> cust_prov
| 38~32 -> cust_prov
| 7~32 -> cust_prov
| 37~32 -> cust_prov
| 33~36 -> prov_cust
| 33~5 -> prov_cust
| 33~2 -> prov_cust
| 26~33 -> cust_prov
| 6~22 -> prov_cust
| 6~40 -> prov_cust
| 6~3 -> prov_cust
| 6~29 -> prov_cust
| 25~6 -> cust_prov
| 4~8 -> prov_cust
| 4~35 -> prov_cust
| 4~13 -> prov_cust
| 1~9 -> prov_cust
| 1~0 -> prov_cust
| 1~20 -> prov_cust
| 1~11 -> prov_cust
| 1~23 -> prov_cust
| 1~24 -> prov_cust
| 34~31 -> prov_cust
| 21~34 -> cust_prov
| 15~34 -> cust_prov
| 33~32 -> peer_peer
| 6~4 -> peer_peer
| 1~4 -> peer_peer
| 1~34 -> peer_peer
| 33~6 -> peer_peer

let init n = if (node_to_int n) = d then Some { bgpAd = 0; lp = 100; aslen = 0; med = 0; comms = {} } else None

let pickOption f x y =
  match (x,y) with
  | (None, None) -> None
  | (None, Some _) -> y  | (Some _, None) -> x
  | (Some a, Some b) -> Some (f a b)

let betterBgp b1 b2 =
  if b1.lp > b2.lp then b1
  else if b2.lp > b1.lp then b2
  else if b1.aslen < b2.aslen then b1
  else if b2.aslen < b1.aslen then b2  else if b1.med >= b2.med then b1 else b2

let mergeBgp x y = pickOption betterBgp x y

let merge n x y = mergeBgp x y

(* We add community tags to designate providers, peers and customers,
 * and use these tags to adjust local preference.
 * We also need to identify when an edge is to a provider or a peer,
 * in which case if the route is tagged as from a customer then it
 * should be dropped.
 * The relationship(a~b) edge function returns:
 * - cust_prov if a is a customer of b (b is a provider for a)
 * - peer_peer if a is a peer of b (should be symmetric)
 * - prov_cust if a is a provider for b (b is a customer of a)
 * A node v will only advertise a route from its neighbor u to another neighbor w according to the following rules:
 * if relationship(uv) = customer, v will advertise the route to w;
 * if relationship(uv) = peer or relationship(uv) = prov, v will only advertise the route to w if relationship(vw) = cust
 *)
let transferBgp e x =
  match x with
  | None -> None
  | Some b -> (
    (* enforce no transit: if the route is neither from a customer nor to a customer, then drop it;
     * don't use !(b.comms[cust_prov]) since by default b.comms starts empty
     *)
    if (b.comms[peer_peer] || b.comms[prov_cust]) && !(relationship e = prov_cust) then None else
    (* update LP *)
    let lp = if (relationship e = cust_prov) then 200
        else if (relationship e = peer_peer) then 100
        else 0
    in
    (* update comms: mark the source of the message and remove old relationship tags *)
    let comms = if (relationship e = cust_prov) then b.comms[cust_prov := true][peer_peer := false][prov_cust := false]
        else if (relationship e = peer_peer) then b.comms[peer_peer := true][cust_prov := false][prov_cust := false]
        else b.comms[prov_cust := true][cust_prov := false][peer_peer := false]
    in
    let b = {b with comms = comms; aslen = b.aslen + 1; lp = lp} in
    Some b
)

let trans e x = transferBgp e x

let assert_node u v = match v with | None -> false | _ -> true

let sol = solution { init = init; trans = trans; merge = merge; }

(* Chisinau RENAM=0, Iasi=1, Arad=2, Satu Mare=3, Mures=4, Bihor=5, Cluj=6, Valcea=7, Covasna=8, Bacau=9, Ialomita=10, Neamt=11, Buzau=12, Harghita=13, Olt=14, Braila=15, Teleorman=16, Bucaresti=17, Prahova=18, Calarasi=19, Vaslui=20, Tulcea=21, Alba=22, Suceava=23, Botosani=24, Salaj=25, Hunedora=26, Giurgiu=27, Arges=28, Maramures=29, Dambovita=30, Vrancea=31, Dolj=32, Timis=33, Galati=34, Sibiu=35, Caras-Severin=36, Mehedinti=37, Gorj=38, Constanta=39, Bistrita-Nasaud=40 *)

assert foldNodes (fun u v acc -> acc && assert_node u v) sol true
