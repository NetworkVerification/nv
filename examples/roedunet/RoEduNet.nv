(* Generated by roedunet.py *)

type bgpType = {bgpAd: int; lp: int; aslen: int; med:int; comms:set[int];}

type attribute = option[bgpType]

let nodes = 41

let edges = {
  3=36; (*Dolj <--> Olt*)
  3=0; (*Dolj <--> Gorj*)
  3=7; (*Dolj <--> Valcea*)
  3=8; (*Dolj <--> Mehedinti*)
  3=40; (*Dolj <--> Timis*)
  12=14; (*Bucaresti <--> Cluj*)
  12=9; (*Bucaresti <--> Ialomita*)
  12=30; (*Bucaresti <--> Teleorman*)
  12=4; (*Bucaresti <--> Giurgiu*)
  12=26; (*Bucaresti <--> Calarasi*)
  12=20; (*Bucaresti <--> Constanta*)
  12=23; (*Bucaresti <--> Dambovita*)
  12=25; (*Bucaresti <--> Prahova*)
  12=38; (*Bucaresti <--> Buzau*)
  12=40; (*Bucaresti <--> Timis*)
  12=1; (*Bucaresti <--> Mures*)
  12=15; (*Bucaresti <--> Galati*)
  12=31; (*Bucaresti <--> Iasi*)
  24=1; (*Covasna <--> Mures*)
  27=14; (*Alba <--> Cluj*)
  21=31; (*Bacau <--> Iasi*)
  19=1; (*Harghita <--> Mures*)
  18=31; (*Chisinau RENAM <--> Iasi*)
  28=14; (*Bistrita-Nasaud <--> Cluj*)
  15=37; (*Galati <--> Tulcea*)
  15=31; (*Galati <--> Iasi*)
  29=31; (*Botosani <--> Iasi*)
  13=40; (*Caras-Severin <--> Timis*)
  14=34; (*Cluj <--> Salaj*)
  14=40; (*Cluj <--> Timis*)
  10=40; (*Bihor <--> Timis*)
  35=40; (*Arad <--> Timis*)
  12=3; (*Bucaresti <--> Dolj*)
  33=12; (*Arges <--> Bucaresti*)
  17=40; (*Hunedora <--> Timis*)
  14=2; (*Cluj <--> Satu Mare*)
  14=39; (*Cluj <--> Maramures*)
  1=16; (*Mures <--> Sibiu*)
  31=11; (*Iasi <--> Vaslui*)
  31=22; (*Iasi <--> Neamt*)
  31=6; (*Iasi <--> Suceava*)
  15=5; (*Galati <--> Vrancea*)
  32=15; (*Braila <--> Galati*)
  14=1; (*Cluj <--> Mures*)
  31=1; (*Iasi <--> Mures*)
}

let cust_prov = 0

let peer_peer = 1

let prov_cust = 2

let relationship e = match e with
| 3~36 -> prov_cust
| 3~0 -> prov_cust
| 3~7 -> prov_cust
| 3~12 -> cust_prov
| 3~8 -> prov_cust
| 3~40 -> peer_peer
| 12~14 -> prov_cust
| 12~9 -> prov_cust
| 12~30 -> prov_cust
| 12~4 -> prov_cust
| 12~26 -> prov_cust
| 12~20 -> prov_cust
| 12~33 -> prov_cust
| 12~23 -> prov_cust
| 12~25 -> prov_cust
| 12~38 -> prov_cust
| 12~40 -> prov_cust
| 12~1 -> prov_cust
| 12~15 -> prov_cust
| 12~31 -> prov_cust
| 24~1 -> cust_prov
| 16~1 -> cust_prov
| 27~14 -> cust_prov
| 5~15 -> cust_prov
| 21~31 -> cust_prov
| 19~1 -> cust_prov
| 18~31 -> cust_prov
| 1~14 -> peer_peer
| 1~31 -> peer_peer
| 28~14 -> cust_prov
| 11~31 -> cust_prov
| 15~37 -> prov_cust
| 15~32 -> prov_cust
| 15~31 -> peer_peer
| 22~31 -> cust_prov
| 6~31 -> cust_prov
| 29~31 -> cust_prov
| 13~40 -> cust_prov
| 2~14 -> cust_prov
| 39~14 -> cust_prov
| 14~34 -> prov_cust
| 14~40 -> peer_peer
| 10~40 -> cust_prov
| 35~40 -> cust_prov
| 40~17 -> prov_cust
| 12~3 -> prov_cust
| 14~12 -> cust_prov
| 9~12 -> cust_prov
| 30~12 -> cust_prov
| 4~12 -> cust_prov
| 26~12 -> cust_prov
| 20~12 -> cust_prov
| 33~12 -> cust_prov
| 23~12 -> cust_prov
| 25~12 -> cust_prov
| 38~12 -> cust_prov
| 40~12 -> cust_prov
| 1~12 -> cust_prov
| 15~12 -> cust_prov
| 31~12 -> cust_prov
| 36~3 -> cust_prov
| 0~3 -> cust_prov
| 7~3 -> cust_prov
| 8~3 -> cust_prov
| 40~13 -> prov_cust
| 40~10 -> prov_cust
| 40~35 -> prov_cust
| 17~40 -> cust_prov
| 14~27 -> prov_cust
| 14~28 -> prov_cust
| 14~2 -> prov_cust
| 14~39 -> prov_cust
| 34~14 -> cust_prov
| 1~24 -> prov_cust
| 1~16 -> prov_cust
| 1~19 -> prov_cust
| 31~21 -> prov_cust
| 31~18 -> prov_cust
| 31~11 -> prov_cust
| 31~22 -> prov_cust
| 31~6 -> prov_cust
| 31~29 -> prov_cust
| 15~5 -> prov_cust
| 37~15 -> cust_prov
| 32~15 -> cust_prov
| 40~3 -> peer_peer
| 14~1 -> peer_peer
| 31~1 -> peer_peer
| 31~15 -> peer_peer
| 40~14 -> peer_peer

let init n = if n = 2n then Some { bgpAd = 0; lp = 100; aslen = 0; med = 0; comms = {} } else None

let pickOption f x y =
  match (x,y) with
  | (None, None) -> None
  | (None, Some _) -> y  | (Some _, None) -> x
  | (Some a, Some b) -> Some (f a b)

let betterBgp b1 b2 =
  if b1.lp > b2.lp then b1
  else if b2.lp > b1.lp then b2
  else if b1.aslen < b2.aslen then b1
  else if b2.aslen < b1.aslen then b2  else if b1.med >= b2.med then b1 else b2

let mergeBgp x y = pickOption betterBgp x y

let merge n x y = mergeBgp x y

(* We add community tags to designate providers, peers and customers,
 * and use these tags to adjust local preference.
 * We also need to identify when an edge is to a provider or a peer,
 * in which case if the route is tagged as from a customer then it
 * should be dropped.
 * The relationship(a~b) edge function returns:
 * - cust_prov if a is a customer of b (b is a provider for a)
 * - peer_peer if a is a peer of b (should be symmetric)
 * - prov_cust if a is a provider for b (b is a customer of a)
 * A node v will only advertise a route from its neighbor u to another neighbor w according to the following rules:
 * if relationship(uv) = customer, v will advertise the route to w;
 * if relationship(uv) = peer or relationship(uv) = prov, v will only advertise the route to w if relationship(vw) = cust
 *)
let transferBgp e x =
  match x with
  | None -> None
  | Some b -> (
    (* enforce no transit: if the route is neither from a customer nor to a customer, then drop it;
     * don't use !(b.comms[cust_prov]) since by default b.comms starts empty
     *)
    if (b.comms[peer_peer] || b.comms[prov_cust]) && !(relationship e = prov_cust) then None else
    (* update LP *)
    let lp = if (relationship e = cust_prov) then 200
        else if (relationship e = peer_peer) then 100
        else 0
    in
    (* update comms: mark the source of the message and remove old relationship tags *)
    let comms = if (relationship e = cust_prov) then b.comms[cust_prov := true][peer_peer := false][prov_cust := false]
        else if (relationship e = peer_peer) then b.comms[peer_peer := true][cust_prov := false][prov_cust := false]
        else b.comms[prov_cust := true][cust_prov := false][peer_peer := false]
    in
    let b = {b with comms = comms; aslen = b.aslen + 1; lp = lp} in
    Some b
)

let trans e x = transferBgp e x

let assert_node u v = match v with | None -> false | _ -> true

let sol = solution { init = init; trans = trans; merge = merge; }

(* {Gorj=0, Mures=1, Satu Mare=2, Dolj=3, Giurgiu=4, Vrancea=5, Suceava=6, Valcea=7, Mehedinti=8, Ialomita=9, Bihor=10, Vaslui=11, Bucaresti=12, Caras-Severin=13, Cluj=14, Galati=15, Sibiu=16, Hunedora=17, Chisinau RENAM=18, Harghita=19, Constanta=20, Bacau=21, Neamt=22, Dambovita=23, Covasna=24, Prahova=25, Calarasi=26, Alba=27, Bistrita-Nasaud=28, Botosani=29, Teleorman=30, Iasi=31, Braila=32, Arges=33, Salaj=34, Arad=35, Olt=36, Tulcea=37, Buzau=38, Maramures=39, Timis=40} *)

assert foldNodes (fun u v acc -> acc && assert_node u v) sol true
