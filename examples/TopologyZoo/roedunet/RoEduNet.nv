(* Generated by topzoo.py *)

type bgpType = {aslen: int; bgpAd: int8; comms: set[int]; lp: int; med: int;}

type attribute = option[bgpType]

let nodes = 41

let edges = {
  2-15; (* Dolj,2 --> Olt,15 *)
  2-39; (* Dolj,2 --> Gorj,39 *)
  2-25; (* Dolj,2 --> Valcea,25 *)
  2-23; (* Dolj,2 --> Bucaresti,23 *)
  2-19; (* Dolj,2 --> Mehedinti,19 *)
  2-11; (* Dolj,2 --> Timis,11 *)
  23-0; (* Bucaresti,23 --> Cluj,0 *)
  23-37; (* Bucaresti,23 --> Ialomita,37 *)
  23-34; (* Bucaresti,23 --> Teleorman,34 *)
  23-24; (* Bucaresti,23 --> Giurgiu,24 *)
  23-20; (* Bucaresti,23 --> Calarasi,20 *)
  23-27; (* Bucaresti,23 --> Constanta,27 *)
  23-4; (* Bucaresti,23 --> Arges,4 *)
  23-14; (* Bucaresti,23 --> Dambovita,14 *)
  23-32; (* Bucaresti,23 --> Prahova,32 *)
  23-3; (* Bucaresti,23 --> Buzau,3 *)
  23-11; (* Bucaresti,23 --> Timis,11 *)
  23-7; (* Bucaresti,23 --> Mures,7 *)
  23-36; (* Bucaresti,23 --> Galati,36 *)
  23-5; (* Bucaresti,23 --> Iasi,5 *)
  29-7; (* Covasna,29 --> Mures,7 *)
  31-7; (* Sibiu,31 --> Mures,7 *)
  22-0; (* Alba,22 --> Cluj,0 *)
  6-36; (* Vrancea,6 --> Galati,36 *)
  38-5; (* Bacau,38 --> Iasi,5 *)
  40-7; (* Harghita,40 --> Mures,7 *)
  1-5; (* Chisinau RENAM,1 --> Iasi,5 *)
  7-0; (* Mures,7 --> Cluj,0 *)
  7-5; (* Mures,7 --> Iasi,5 *)
  13-0; (* Bistrita-Nasaud,13 --> Cluj,0 *)
  10-5; (* Vaslui,10 --> Iasi,5 *)
  36-12; (* Galati,36 --> Tulcea,12 *)
  36-18; (* Galati,36 --> Braila,18 *)
  36-5; (* Galati,36 --> Iasi,5 *)
  21-5; (* Neamt,21 --> Iasi,5 *)
  16-5; (* Suceava,16 --> Iasi,5 *)
  35-5; (* Botosani,35 --> Iasi,5 *)
  28-11; (* Caras-Severin,28 --> Timis,11 *)
  26-0; (* Satu Mare,26 --> Cluj,0 *)
  30-0; (* Maramures,30 --> Cluj,0 *)
  0-9; (* Cluj,0 --> Salaj,9 *)
  0-11; (* Cluj,0 --> Timis,11 *)
  33-11; (* Bihor,33 --> Timis,11 *)
  17-11; (* Arad,17 --> Timis,11 *)
  11-8; (* Timis,11 --> Hunedora,8 *)
  23-2; (* Bucaresti,23 --> Dolj,2 *)
  0-23; (* Cluj,0 --> Bucaresti,23 *)
  37-23; (* Ialomita,37 --> Bucaresti,23 *)
  34-23; (* Teleorman,34 --> Bucaresti,23 *)
  24-23; (* Giurgiu,24 --> Bucaresti,23 *)
  20-23; (* Calarasi,20 --> Bucaresti,23 *)
  27-23; (* Constanta,27 --> Bucaresti,23 *)
  4-23; (* Arges,4 --> Bucaresti,23 *)
  14-23; (* Dambovita,14 --> Bucaresti,23 *)
  32-23; (* Prahova,32 --> Bucaresti,23 *)
  3-23; (* Buzau,3 --> Bucaresti,23 *)
  11-23; (* Timis,11 --> Bucaresti,23 *)
  7-23; (* Mures,7 --> Bucaresti,23 *)
  36-23; (* Galati,36 --> Bucaresti,23 *)
  5-23; (* Iasi,5 --> Bucaresti,23 *)
  15-2; (* Olt,15 --> Dolj,2 *)
  39-2; (* Gorj,39 --> Dolj,2 *)
  25-2; (* Valcea,25 --> Dolj,2 *)
  19-2; (* Mehedinti,19 --> Dolj,2 *)
  11-28; (* Timis,11 --> Caras-Severin,28 *)
  11-33; (* Timis,11 --> Bihor,33 *)
  11-17; (* Timis,11 --> Arad,17 *)
  8-11; (* Hunedora,8 --> Timis,11 *)
  0-22; (* Cluj,0 --> Alba,22 *)
  0-13; (* Cluj,0 --> Bistrita-Nasaud,13 *)
  0-26; (* Cluj,0 --> Satu Mare,26 *)
  0-30; (* Cluj,0 --> Maramures,30 *)
  9-0; (* Salaj,9 --> Cluj,0 *)
  7-29; (* Mures,7 --> Covasna,29 *)
  7-31; (* Mures,7 --> Sibiu,31 *)
  7-40; (* Mures,7 --> Harghita,40 *)
  5-38; (* Iasi,5 --> Bacau,38 *)
  5-1; (* Iasi,5 --> Chisinau RENAM,1 *)
  5-10; (* Iasi,5 --> Vaslui,10 *)
  5-21; (* Iasi,5 --> Neamt,21 *)
  5-16; (* Iasi,5 --> Suceava,16 *)
  5-35; (* Iasi,5 --> Botosani,35 *)
  36-6; (* Galati,36 --> Vrancea,6 *)
  12-36; (* Tulcea,12 --> Galati,36 *)
  18-36; (* Braila,18 --> Galati,36 *)
  11-2; (* Timis,11 --> Dolj,2 *)
  0-7; (* Cluj,0 --> Mures,7 *)
  5-7; (* Iasi,5 --> Mures,7 *)
  5-36; (* Iasi,5 --> Galati,36 *)
  11-0; (* Timis,11 --> Cluj,0 *)
}

let cust_prov = 0

let peer_peer = 1

let prov_cust = 2

let relationship e = match e with
| 2~15 -> prov_cust
| 2~39 -> prov_cust
| 2~25 -> prov_cust
| 2~23 -> cust_prov
| 2~19 -> prov_cust
| 2~11 -> peer_peer
| 23~0 -> prov_cust
| 23~37 -> prov_cust
| 23~34 -> prov_cust
| 23~24 -> prov_cust
| 23~20 -> prov_cust
| 23~27 -> prov_cust
| 23~4 -> prov_cust
| 23~14 -> prov_cust
| 23~32 -> prov_cust
| 23~3 -> prov_cust
| 23~11 -> prov_cust
| 23~7 -> prov_cust
| 23~36 -> prov_cust
| 23~5 -> prov_cust
| 29~7 -> cust_prov
| 31~7 -> cust_prov
| 22~0 -> cust_prov
| 6~36 -> cust_prov
| 38~5 -> cust_prov
| 40~7 -> cust_prov
| 1~5 -> cust_prov
| 7~0 -> peer_peer
| 7~5 -> peer_peer
| 13~0 -> cust_prov
| 10~5 -> cust_prov
| 36~12 -> prov_cust
| 36~18 -> prov_cust
| 36~5 -> peer_peer
| 21~5 -> cust_prov
| 16~5 -> cust_prov
| 35~5 -> cust_prov
| 28~11 -> cust_prov
| 26~0 -> cust_prov
| 30~0 -> cust_prov
| 0~9 -> prov_cust
| 0~11 -> peer_peer
| 33~11 -> cust_prov
| 17~11 -> cust_prov
| 11~8 -> prov_cust
| 23~2 -> prov_cust
| 0~23 -> cust_prov
| 37~23 -> cust_prov
| 34~23 -> cust_prov
| 24~23 -> cust_prov
| 20~23 -> cust_prov
| 27~23 -> cust_prov
| 4~23 -> cust_prov
| 14~23 -> cust_prov
| 32~23 -> cust_prov
| 3~23 -> cust_prov
| 11~23 -> cust_prov
| 7~23 -> cust_prov
| 36~23 -> cust_prov
| 5~23 -> cust_prov
| 15~2 -> cust_prov
| 39~2 -> cust_prov
| 25~2 -> cust_prov
| 19~2 -> cust_prov
| 11~28 -> prov_cust
| 11~33 -> prov_cust
| 11~17 -> prov_cust
| 8~11 -> cust_prov
| 0~22 -> prov_cust
| 0~13 -> prov_cust
| 0~26 -> prov_cust
| 0~30 -> prov_cust
| 9~0 -> cust_prov
| 7~29 -> prov_cust
| 7~31 -> prov_cust
| 7~40 -> prov_cust
| 5~38 -> prov_cust
| 5~1 -> prov_cust
| 5~10 -> prov_cust
| 5~21 -> prov_cust
| 5~16 -> prov_cust
| 5~35 -> prov_cust
| 36~6 -> prov_cust
| 12~36 -> cust_prov
| 18~36 -> cust_prov
| 11~2 -> peer_peer
| 0~7 -> peer_peer
| 5~7 -> peer_peer
| 5~36 -> peer_peer
| 11~0 -> peer_peer

let init n = if n = 0n then Some {  aslen= 0u32; bgpAd= 20u8; comms= { _ |-> false }; lp= 100u32; med= 80u32; } else None

let pickOption f x y =
  match (x,y) with
  | (None, None) -> None
  | (None, Some _) -> y  | (Some _, None) -> x
  | (Some a, Some b) -> Some (f a b)

let betterBgp b1 b2 =
  if b1.lp > b2.lp then b1
  else if b2.lp > b1.lp then b2
  else if b1.aslen < b2.aslen then b1
  else if b2.aslen < b1.aslen then b2  else if b1.med >= b2.med then b1 else b2

let mergeBgp x y = pickOption betterBgp x y

let merge n x y = mergeBgp x y

(* We add community tags to designate providers, peers and customers,
* and use these tags to adjust local preference.
* We also need to identify when an edge is to a provider or a peer,
* in which case if the route is tagged as from a customer then it
* should be dropped.
* The relationship(a~b) edge function returns:
* - cust_prov if a is a customer of b (b is a provider for a)
* - peer_peer if a is a peer of b (should be symmetric)
* - prov_cust if a is a provider for b (b is a customer of a)
* A node v will only advertise a route from its neighbor u to another neighbor w according to the following rules:
* if relationship(uv) = customer, v will advertise the route to w;
* if relationship(uv) = peer or relationship(uv) = prov, v will only advertise the route to w if relationship(vw) = cust
*)
let transferBgp e x =
match x with
| None -> None
| Some b -> (
    (* enforce no transit: if the route is neither from a customer nor to a customer, then drop it;
    * don't use !(b.comms[cust_prov]) since by default b.comms starts empty
    *)
    if (b.comms[peer_peer] || b.comms[prov_cust]) && !(relationship e = prov_cust) then None else
    (* update LP *)
    let lp = if (relationship e = cust_prov) then 200
        else if (relationship e = peer_peer) then 100
        else 0
    in
    (* update comms: mark the source of the message and remove old relationship tags *)
    let comms = if (relationship e = cust_prov) then b.comms[cust_prov := true][peer_peer := false][prov_cust := false]
        else if (relationship e = peer_peer) then b.comms[peer_peer := true][cust_prov := false][prov_cust := false]
        else b.comms[prov_cust := true][cust_prov := false][peer_peer := false]
    in
    let b = {b with comms = comms; aslen = b.aslen + 1; lp = lp} in
    Some b
)

let trans e x = transferBgp e x

let assert_node u v = match v with | None -> false | _ -> true

let sol = solution { init = init; trans = trans; merge = merge; }

(* {Cluj,0=0, Chisinau RENAM,1=1, Dolj,2=2, Buzau,3=3, Arges,4=4, Iasi,5=5, Vrancea,6=6, Mures,7=7, Hunedora,8=8, Salaj,9=9, Vaslui,10=10, Timis,11=11, Tulcea,12=12, Bistrita-Nasaud,13=13, Dambovita,14=14, Olt,15=15, Suceava,16=16, Arad,17=17, Braila,18=18, Mehedinti,19=19, Calarasi,20=20, Neamt,21=21, Alba,22=22, Bucaresti,23=23, Giurgiu,24=24, Valcea,25=25, Satu Mare,26=26, Constanta,27=27, Caras-Severin,28=28, Covasna,29=29, Maramures,30=30, Sibiu,31=31, Prahova,32=32, Bihor,33=33, Teleorman,34=34, Botosani,35=35, Galati,36=36, Ialomita,37=37, Bacau,38=38, Gorj,39=39, Harghita,40=40} *)

assert foldNodes (fun u v acc -> acc && assert_node u v) sol true
