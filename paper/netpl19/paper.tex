\documentclass[sigconf,10pt]{acmart}
\usepackage{amsmath}           % basic math features
\usepackage{amssymb}           % basic additional symbols
\usepackage{accents}           % mathematicsl accents like hat, vector etc.
\usepackage{xcolor}            % create and use custom colors (e.g., for highlighting)
\usepackage{xspace}            % adds a space if needed at the end of a macro
\usepackage{balance}           % \balance to the last page makes refs symmetric
\usepackage{enumitem}          % allows customizing lists
\usepackage[utf8]{inputenc}    % document encoding set to utf8
\usepackage{graphicx}          % better includegraphics command
\usepackage{etoolbox}          % enable patching commands, for below
\patchcmd{\quote}{\rightmargin}{\leftmargin 1em \rightmargin}{}{}
\usepackage{amsthm}            % basic theorems
\usepackage{thmtools}          % more flexible theorems
\usepackage{thm-restate}       % repeat theorems in appendix if needed
\usepackage{hyperref}          % hyper-text links
\usepackage{cleveref}          % smarter type-based cross-references
\usepackage{apptools}          % customizable appendix
\usepackage{local}             % user-defined commands stored in local.sty
\usepackage{listings}

\lstset{language=ML}
\lstdefinestyle{customml}{
  belowcaptionskip=1\baselineskip,
  breaklines=true,
  frame=L,
  xleftmargin=\parindent,
  language=ML,
  showstringspaces=false,
  basicstyle=\footnotesize\ttfamily,
  keywordstyle=\bfseries\color{purple!40!black},
  commentstyle=\itshape\color{blue!40!black},
  identifierstyle=\color{black},
  stringstyle=\color{orange},
}


% break long urls in the bibliography
\def\UrlBreaks{\do\/\do-}
\hypersetup{breaklinks=true}
%\hypersetup{draft}

% reclaim the copyright space for the draft
\settopmatter{printacmref=false}
\renewcommand\footnotetextcopyrightpermission[1]{}
\pagestyle{plain}

\begin{document}
\title{NV: An intermediate language for network verification}


\maketitle

%=====================================================
%
%
%  **Introduction**
%
%
%=====================================================

\paragraph{Introduction} 

Network devices often rely on distributed protocols, such as BGP, to
make routing decisions. Network operators can enforce routing policies
(that may express security, economic or other concerns) by configuring
what routing protocols each device executes, how it uses the routing
information received by neighbors and what routing information it
shares. These configurations are expressed in low-level, vendor
specific languages. Combined with the distributed nature of routing
protocols, reasoning about the correctness of the configurations --
and in extension, of the network -- is a daunting task for operators.
Network verification \cite{minesweeper,arc} and simulation tools
\cite{batfish} have been proposed to aid operators. Additionally, as
those techniques often face scaling problems, researchers have
suggested network transformations \cite{bonsai, origami} in order to
simplify the complexity of networks.

Regardless of the transformation or reasoning principles used, one
needs to parse the original network configurations as provided by
operators. To tackle the range of vendor-specific configurations,
Batfish \cite{batfish} uses a vendor-agnostic representation of
routing configurations for common protocols, and provides a translation from each vendor's
language to Batfish's representation. Subsequent analysis such as
compression \cite{bonsai}, simulation \cite{batfish} or verification
\cite{minesweeper,arc} can be then performed on top of this
representation.

Batfish has been an indispensable tool for network researchers thanks
to its ability to parse a wide range of configurations from different
vendors. Unfortunately, its intermediate language (IR) falls short of
many language design goals. First, at 105 different expressions and 23
statements Batfish's IR is \emph{massive}. This is a symptom of other
problems in the design of the IR. In particular, the expressions and
structures used are highly \emph{specialized} to common routing
protocols, e.g. instead of a set operation that specifies the field of
the attribute to be changed and its new value, Batfish uses a
different expression to set the local preference of a BGP attribute, a
different expression to set the MED value, and so on. As such,
expressions cannot be \emph{composed} to build other more complex
operations. Besides the explosion in the size of the IR, this poses
another issue: desirable transformations often cannot be expressed
within Batfish's IR. For instance, replacing the \texttt{AS Path}
attribute of BGP with its length, can often improve simulation
performance without loss of precision. Yet, this simple transformation
cannot be expressed within Batfish's current AST, because one cannot
alter the type of the \texttt{AS Path} or the operations on
it. Moreover, the semantics of the language requires a deep
understanding of routing protocols and the intricacies of vendor
specific implementations to understand. As a consequence, because of
the size of the language and the complexity of its semantics, writing
new analyses over configurations is often a tedious task.

Finally, Batfish suffers from the fact that some effects of executing
a protocol are not expressed in the configurations, but are left
\emph{implicit} and it's up to the backend (simulator, SMT verifier,
etc.) to correctly capture them. This makes it difficult to implement
new analyses of configurations, as one has to ensure he correctly
implemented any implicit effects operations may have.
%Potentially mention that this poses a maintenance problem.

\paragraph{NV: A flexible IR for control plane configurations}

To overcome these limitations, we propose a typed intermediate
language, called NV. NV allows the user to specify the topology of a
network, the type of the routing messages exchanged, and finally,
functions that define how each network device processes these
messages. The key design points of NV are its compact size, the
compositionality of its expressions, and the use of standard
programming language constructs (similar to the ones found in ML based
languages). Currently, we have implemented two different backends to
NV, a BDD-based simulator that simulates the message exchange
procedure of distributed routing protocols, and a SMT-based logical
encoding that can verify properties of the stable (converged) state of
a network. Furthermore, to improve the performance of such techniques
we have implemented some common compiler optimizations such as
constant unfolding, inlining and partial evaluation. The small size
and the use of standard constructs with well-defined semantics,
significantly facilitate the implementation (and the reasoning about
the correctness) of such optimizations.

NV is designed to be not only a configuration language, but a
verification framework, as well. NV includes two key features that
support this role: 1. symbolic variables that represent unknowns in
the network and can take up any value allowed by their type and
2. assertions to be verified about the network's converged state.  For
instance, one could use a symbolic variable to model a potential link
failure, or a routing advertisement from an external peer. 

Finally, for NV to be useful, it must be able to (at least) model the
commonly used routing protocols, such as BGP and OSPF. One of the
challenges we face, is to find a language that is sufficient to model
all the intricacies of these protocols, but that we can also
efficiently compile to BDDs or logical formulas to be verified by an
SMT solver. Currently, we can translate a number of protocol
configurations from Batfish to NV, including eBGP and OSPF, and we are
working towards supporting more complicated protocols such as iBGP.


% On a similar note, Batfish's specialized expressions provide room for
% specialized (in terms of efficiency) interpretations. For example,
% when simulating a network that runs iBGP over some IGP, Batfish will
% not simulate the iBGP part until the IGP has converged. This and other
% similar optimizations help speed up the simulation. In an IR where
% iBGP and IGP are not directly exposed, but rather are build from
% smaller blocks, it is not straightforward to implement such
% optimizations. Exploiting the high-level structure of the
% configurations to -- among other things -- improve the performance of
% the simulation is an important future direction.
\paragraph{Related Work} A word on routing algebras. 


 
\bibliographystyle{abbrv}
\bibliography{references}

\end{document}