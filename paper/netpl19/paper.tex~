\documentclass[sigconf,10pt]{acmart}
\usepackage{amsmath}           % basic math features
\usepackage{amssymb}           % basic additional symbols
\usepackage{accents}           % mathematicsl accents like hat, vector etc.
\usepackage{xcolor}            % create and use custom colors (e.g., for highlighting)
\usepackage{xspace}            % adds a space if needed at the end of a macro
\usepackage{balance}           % \balance to the last page makes refs symmetric
\usepackage{enumitem}          % allows customizing lists
\usepackage[utf8]{inputenc}    % document encoding set to utf8
\usepackage{graphicx}          % better includegraphics command
\usepackage{etoolbox}          % enable patching commands, for below
\patchcmd{\quote}{\rightmargin}{\leftmargin 1em \rightmargin}{}{}
\usepackage{amsthm}            % basic theorems
\usepackage{thmtools}          % more flexible theorems
\usepackage{thm-restate}       % repeat theorems in appendix if needed
\usepackage{hyperref}          % hyper-text links
\usepackage{cleveref}          % smarter type-based cross-references
\usepackage{apptools}          % customizable appendix
\usepackage{local}             % user-defined commands stored in local.sty
\usepackage{listings}

\lstset{language=ML}
\lstdefinestyle{customml}{
  belowcaptionskip=1\baselineskip,
  breaklines=true,
  frame=L,
  xleftmargin=\parindent,
  language=ML,
  showstringspaces=false,
  basicstyle=\footnotesize\ttfamily,
  keywordstyle=\bfseries\color{purple!40!black},
  commentstyle=\itshape\color{blue!40!black},
  identifierstyle=\color{black},
  stringstyle=\color{orange},
}


% break long urls in the bibliography
\def\UrlBreaks{\do\/\do-}
\hypersetup{breaklinks=true}
%\hypersetup{draft}

% reclaim the copyright space for the draft
\settopmatter{printacmref=false}
\renewcommand\footnotetextcopyrightpermission[1]{}
\pagestyle{plain}

\begin{document}
\title{NV: An intermediate language for network verification}


\maketitle

%=====================================================
%
%
%  **Introduction**
%
%
%=====================================================

\paragraph{Introduction} 

Network devices often rely on distributed protocols, such as BGP, to
make routing decisions. Network operators can enforce routing policies
(that may express security, economic or other concerns) by configuring
what routing protocols each device executes, how it uses the routing
information received by neighbors and what routing information it
shares. These configurations are expressed in low-level, vendor
specific languages. Combined with the distributed nature of routing
protocols, reasoning about the correctness of the configurations --
and in extension, of the network -- is a daunting task for operators.
Network verification \cite{minesweeper,arc} and simulation tools
\cite{batfish} have been proposed to aid operators. Additionally, as
those techniques often face scaling problems, researchers have
suggested network transformations \cite{bonsai, origami} in order to
simplify the complexity of networks.

\paragraph{Modelling network configurations}
Irregardless of the transformation or reasoning principles used, one
needs to parse the original network configurations as provided by
operators. Batfish \cite{batfish} was the first to tackle this
problem, by devising a vendor-agnostic representation of common
routing protocols and providing a translation from each vendor's
language to the Batfish representation, a concept akin to intermediate
languages, such as LLVM, in compilers. Subsequent analysis such as
compression \cite{bonsai}, simulation \cite{batfish} or verification
\cite{minesweeper,arc} can be then performed on top of this
representation.

Batfish has been an indispensable tool for network researchers thanks
to its ability to parse a wide range of configurations from different
vendors. Unfortunately, its intermediate language (IR) falls short of
many language design goals. First, at 105 different expressions and 23
statements Batfish's IR is \emph{massive}. This is a symptom of other
problems in the design of the IR. In particular, the expressions and
structures used are highly \emph{specialized} to common routing
protocols (e.g. expression to set the local preference of a BGP
attribute). As such, they cannot be \emph{composed} to build other
operations. Besides the explosion in the size of the IR, this poses
another issue: desirable transformations often cannot be expressed
within Batfish's IR. For instance, replacing the \texttt{AS Path}
attribute of BGP with its length, can often improve simulation
performance without loss of precision. Yet, this simple transformation
cannot be expressed within Batfish's current AST.  Moreover, the
semantics of the language requires a deep understanding of routing
protocols and the intricacies of vendor specific implementations to
understand. As a consequence, because of the size of the language and
the complexity of its semantics, writing new analyses over
configurations is often a tedious task. 

Finally, Batfish suffers from the fact that some effects of executing
a protocol are not expressed in the configurations, but are left
\emph{implicit} and it's up to the backend (simulator, SMT verifier,
etc.) to correctly capture them. This makes it notoriously difficult
to analyze configurations, one has to look at the backend to
understand the semantics of configurations. It also makes it harder to
keep the various backends in sync.

\paragraph{NV: A flexible IR for control plane configurations}

To overcome these limitations, we propose an intermediate language,
called NV, that is based on the ML programming language
\cite{milner1978theory}. As the basis of many modern programming
languages, ML has been widely studied and has a \emph{rigorous
  semantics}. As a result, one does not need to be an expert in
routing protocols to understand an NV program. Importantly, we
demonstrate that with just \emph{a few} standard constructs (options,
pairs, booleans/integers and their operations, functions,
dictionaries, graphs, match statements) we can clearly express the
configurations of common routing protocols such as BGP and OSPF, by
translating the Batfish IR to NV. 

Implementing and reasoning about the correctness of transformations of
NV code is facilitated by the small size of the language and the
simplicity of its semantics. For instance, it is straightforward to
implement common compiler transformations such as constant folding and
inlining, to improve the performance of simulation/verification. Or a
transformation where the path component of BGP is replaced by an
integer. Moreover, because the semantics of the program remain
explicit, those transformations do not require any change in
subsequent tools in the toolchain (such as a Batfish style simulator,
or an SMT verifier).

\paragraph{Challenges}

When defining a new IR we have to balance the tension between
expressiveness of the language, i.e. the ability to accurately
describe common routing protocols and potentially new ones, and the
efficiency of simulation/verification techniques. For instance, total
maps are a prelevant data structure in the context of networks, but
they do not admit an efficient or complete SMT encoding of their semantics.   an it
imposes restrictions in their usage that makes it possible to provide
an efficient SMT encoding to their semantics. In a general purpose
language these restrictions may not make sense

the
fact that Batfish's IR has very specialized constructs, allows 


* Finding the right balance between expressiveness, completeness and
efficiency (e.g. maps, recursion) 

* Restoring some of the high-level structure of Batfish's IR. Despite,
its rigidness, Batfish's high-level IR can be exploited to improve the
performance of simulation/verification. For instance, the simulator
can choose an efficient schedule depending on the protocols being run
and the dependencies between them.

* ?


 
\bibliographystyle{abbrv}
\bibliography{references}

\end{document}