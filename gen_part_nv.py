#!/usr/bin/env python3
"""
gen_part_nv.py [spfile]
A module for generating spX-part.nv fileoutput from spX.nv files.
"""
import os
import re
import argparse

# used for constructing the graph
import igraph

# Partition cut types
CUTS = [
    # vertical cut: 2 parts
    "v",
    "vertical",
    # horizontal cut: 3 parts
    "h",
    "horizontal",
    # horizontal cut with all pods separate
    "p",
    "pods",
    # horizontal cut with all spines and pods separate
    "s",
    "spines",
    # full cut with every node in its own partition
    "f",
    "full",
]

# Group
# Core nodes are on the spine, edge nodes are ToR,
# and aggregation nodes are between core and edge nodes
CORE = 0
AGGREGATION = 1
EDGE = 2

# Network types
SP = 0
FATPOL = 1


def to_grp(name):
    if name == "core":
        return CORE
    elif name == "aggregation":
        return AGGREGATION
    elif name == "edge":
        return EDGE
    else:
        raise Exception("group name not recognized!")


def construct_graph(text):
    """
    Construct a digraph from the given edge and node information.
    """
    g = igraph.Graph(directed=True)
    for (v, grp) in find_nodes(text):
        g.add_vertex(g=grp)
    g.add_edges(find_edges(text))
    # add stable node numbering
    for v in g.vs:
        v["id"] = v.index
    return g


def find_edges(text):
    """Return the edges."""
    prog = re.compile(
        r"(\d*)-(\d*); "
        r"\(\*(core|aggregation|edge)-\d*,Serial\d*"
        r" --> (core|aggregation|edge)-\d*,Serial\d*\*\)"
    )
    matches = prog.finditer(text)
    outputs = [(int(m.group(1)), int(m.group(2))) for m in matches]
    outputs.sort()
    return outputs


def find_nodes(text):
    """Return the nodes."""
    prog = re.compile(r"(core|aggregation|edge)-\d*=(\d*)")
    # find all nodes
    matches = prog.finditer(text)
    vertices = [(int(m.group(2)), to_grp(m.group(1))) for m in matches]
    vertices.sort()
    return vertices


def write_preamble(spname, cut):
    """
    Return the string representation of the preamble.
    """
    vim_modeline = "(* vim: set syntax=ocaml: *)"
    if cut == "v" or cut == "vertical":
        oriented = "Vertically partitioned"
    elif cut == "h" or cut == "horizontal":
        oriented = "Horizontally partitioned"
    elif cut == "p" or cut == "pods":
        oriented = "Partitioned into pods"
    elif cut == "s" or cut == "spines":
        oriented = "Partitioned into pods and individual spines"
    elif cut == "f" or cut == "full":
        oriented = "Fully partitioned"
    else:
        raise Exception("Unexpected cut type")
    file_info = f"(* {oriented} version of {spname} *)"
    generated_by = "(* Automatically generated by gen_part_nv.py *)"
    include_utils = 'include "../../../examples/utils.nv"'
    return "\n".join([vim_modeline, file_info, generated_by, include_utils])


def write_partition_str(partitions):
    """
    Return the string representation of the partition function.
    """
    output = "let partition node = match node with\n"
    for i, nodes in enumerate(partitions):
        output += "\n".join([f"  | {node}n -> {i}u8" for node in nodes]) + "\n"
    return output


def write_interface_str(fwd_edges, net_type):
    """
    Return the string representation of the interface function.
    """
    output = "let interface edge ="
    output += """
  let hasOnlyBgp f x =
    x.selected = Some 3u2 && (match x.bgp with
      | Some b -> f b
      | None -> false)
  in"""
    if net_type == FATPOL:
        output += """
  let ignoreBgp x = match x.bgp with
    | Some b -> ignore b.comms
    | None -> true
  in"""
        default = (
            "(fun x -> match x.bgp with | Some b -> ignore b.comms | None -> true)"
        )
    elif net_type == SP:
        default = "(fun x -> true)"
    else:
        raise Exception("Unexpected net type")
    output += "\n  match edge with\n"
    for (start, end) in fwd_edges:
        if net_type == SP:
            fn = "(fun b -> true)"
        elif net_type == FATPOL:
            fn = "(fun b -> ignore b.comms)"
        output += f"  | {start}~{end} -> hasOnlyBgp {fn}\n"
    output += f"  | _ -> {default}\n"
    return output


def get_part_fname(spfile, cut):
    """
    Return the name of the partition file for the corresponding nv file,
    and the network type.
    """
    spdir, spname = os.path.split(spfile)
    root, nvext = os.path.splitext(spname)
    if root.startswith("sp"):
        net_type = SP
    elif root.startswith("fat"):
        net_type = FATPOL
    else:
        raise Exception("Unexpected network type based on name")
    prefix = f"{root}-{cut}"
    partfile = os.path.join(spdir, prefix + nvext)
    suffix = 1
    # don't overwrite an existing path: instead, create a new file
    while os.path.exists(partfile):
        partfile = os.path.join(spdir, prefix + str(suffix) + nvext)
        suffix += 1
    return partfile, net_type


def nodes_cut_fully(graph, dest):
    """
    Return the nodes divided up fully into separate partitions.
    Order is established by BFS.
    """
    return [[v["id"]] for v in graph.bfsiter(dest)]


def nodes_cut_spines(graph, dest):
    """
    Return the nodes divided up such that the destination's pod
    is in one partition, the spine nodes are each in another
    and the other pod nodes are each in another.
    """
    podgraph = graph.subgraph(graph.vs.select(g_ne=CORE))
    pods = podgraph.decompose()
    dest_idx = 0
    for (i, pod) in enumerate(pods):
        if dest in pod.vs["id"]:
            dest_idx = i
    spines = [v["id"] for v in graph.vs.select(g_eq=CORE)]
    nondest_pods = [list(pod.vs["id"]) for pod in pods]
    dest_pod = nondest_pods.pop(dest_idx)
    dest_pod.sort()
    spines.sort()
    for pod in nondest_pods:
        pod.sort()
    return [dest_pod] + [[s] for s in spines] + nondest_pods


def nodes_cut_pods(graph, dest):
    """
    Return the nodes divided up such that the destination's pod
    is in one partition, the spine nodes are in another and the
    other pod nodes are each in another.
    """
    podgraph = graph.subgraph(graph.vs.select(g_ne=CORE))
    pods = podgraph.decompose()
    dest_idx = 0
    for (i, pod) in enumerate(pods):
        if dest in pod.vs["id"]:
            dest_idx = i
    spines = [v["id"] for v in graph.vs.select(g_eq=CORE)]
    nondest_pods = [list(pod.vs["id"]) for pod in pods]
    dest_pod = nondest_pods.pop(dest_idx)
    dest_pod.sort()
    spines.sort()
    for pod in nondest_pods:
        pod.sort()
    return [dest_pod, spines] + nondest_pods


def nodes_cut_horizontally(graph, dest):
    """
    Return the nodes divided up such that the destination's pod
    is in one partition, the spine nodes are in another and the
    other pod nodes are in a third.
    """
    podgraph = graph.subgraph(graph.vs.select(g_ne=CORE))
    pods = podgraph.decompose()
    dest_pod = []
    nondest_pods = []
    for pod in pods:
        if dest in pod.vs["id"]:
            dest_pod = [v["id"] for v in pod.vs]
        else:
            nondest_pods += [v["id"] for v in pod.vs]
    spines = [v["id"] for v in graph.vs.select(g_eq=CORE)]
    dest_pod.sort()
    spines.sort()
    nondest_pods.sort()
    return dest_pod, spines, nondest_pods


def nodes_cut_vertically(graph, dest):
    """
    Return the nodes divided up such that half of the spine
    nodes and half of the pods are in one partition
    and the others are in another.
    """
    spines = [v for v in graph.vs.select(g_eq=CORE)]
    half_spines = spines[: (len(spines) // 2)]
    aggs = [v for v in graph.vs.select(g_eq=AGGREGATION)]
    half_aggs = aggs[: (len(aggs) // 2)]
    # use a set so as not to add twice
    pods = set()
    for v in half_aggs:
        pods.add(v.index)
        for u in v.neighbors():
            if u["g"] == EDGE:
                pods.add(u.index)
    # return half of the spines along with the pods
    group1 = [x.index for x in half_spines] + list(pods)
    # get all nodes not in group1
    all_nodes = set(x.index for x in graph.vs)
    group2 = [x for x in all_nodes.difference(set(group1))]
    group1.sort()
    group2.sort()
    if dest in group1:
        return group1, group2
    else:
        return group2, group1


def validate(spine_nodes, cross_edges):
    """Validate that every cross edge goes to or from a spine node."""
    for (start, end) in cross_edges:
        if start not in spine_nodes and end not in spine_nodes:
            warn = "Warning: Edge {},{} does not connect to the spine!"
            print(warn.format(start, end))


def get_cross_edges(graph, partitions):
    """
    Get the edges in the network which go from lower-ranked partitions to
    higher-ranked partitions. These edges are used to determine the interface
    functions.
    """
    # construct a map of nodes to their partitions
    node_part = {node: i for (i, part) in enumerate(partitions) for node in part}
    return [e.tuple for e in graph.es if node_part[e.source] < node_part[e.target]]


def get_vertical_cross_edges(graph, partitions, dest):
    all_cross = get_cross_edges(graph, partitions)
    updated = []
    for e in all_cross:
        # prune non-destination-pod cross edges
        node = graph.vs[e[0]]
        neighbors = [v["id"] for v in node.neighbors()]
        if node["g"] == AGGREGATION and dest not in neighbors:
            continue
        else:
            updated.append(e)
    return updated


def cut_nodes(graph, dest, cut):
    """
    Cut the graph's nodes into a list of list of nodes in partition rank order,
    based on the given destination (always in the 0th partition) and the type
    of cut desired.
    """
    if cut == "vertical" or cut == "v":
        nodes = nodes_cut_vertically(graph, dest)
    elif cut == "horizontal" or cut == "h":
        nodes = nodes_cut_horizontally(graph, dest)
    elif cut == "pods" or cut == "p":
        nodes = nodes_cut_pods(graph, dest)
    elif cut == "spines" or cut == "s":
        nodes = nodes_cut_spines(graph, dest)
    elif cut == "full" or cut == "f":
        nodes = nodes_cut_fully(graph, dest)
    else:
        raise Exception("Unexpected cut type")
    return nodes


def split_prefooter(sptext):
    prog = re.compile(r"\(\* {((edge|core|aggregation)-\d+=\d+,?\s*)*}\*\)")
    match = prog.search(sptext)
    end = match.end()
    return (sptext[: end + 1], sptext[end + 1 :])


def gen_part_nv(spfile, dest, cut, verbose=False):
    """Generate the partition file."""
    part, net_type = get_part_fname(spfile, cut)
    if verbose:
        print("Outfile: " + part)
    with open(spfile, "r") as inputfile:
        sptext = inputfile.read()
    # compute the graph topology
    graph = construct_graph(sptext)
    if verbose:
        print(str(graph))
    # get the three parts
    preamble = write_preamble(os.path.basename(spfile), cut)
    include_sp, footer = split_prefooter(sptext)
    if net_type == FATPOL:
        global_def = """
let global x = match x.bgp with
  | Some b -> b.lp = 100 && b.med = 80
  | None -> true
"""
        include_sp += global_def
    nodes = cut_nodes(graph, dest, cut)
    # special case for handling vertical cuts
    if net_type == FATPOL and (cut == "vertical" or cut == "v"):
        fwd_cross = get_vertical_cross_edges(graph, nodes, dest)
    else:
        fwd_cross = get_cross_edges(graph, nodes)
    if verbose:
        print(nodes)
        print([e for e in fwd_cross])
    partition = write_partition_str(nodes)
    interface = write_interface_str(fwd_cross, net_type)
    # perform the decomposed transfer on the input side
    if net_type == SP:
        repl = (
            r"solution { init = init; trans = trans; merge = merge;"
            r" interface = interface; rtrans = trans }"
        )
    elif net_type == FATPOL:
        repl = (
            r"solution { init = init; trans = trans; merge = merge;"
            r" interface = interface; rtrans = trans; global = global }"
        )
    solution = re.sub(r"solution {.*}", repl, footer)
    # put 'em all together
    output = "\n".join([preamble, include_sp, partition, interface, solution])
    with open(part, "w") as outfile:
        outfile.write(output)
    print(f"Saved network to {part}")


def main():
    parser = argparse.ArgumentParser(
        description="Generate partitioned versions of network benchmarks."
    )
    parser.add_argument("file", type=str, help="unpartitioned network file")
    parser.add_argument(
        "dest", type=int, help="destination node in a shortest-path network"
    )
    parser.add_argument("cut", type=str, choices=CUTS, help="type of cut")
    parser.add_argument(
        "-v", "--verbose", action="store_true", help="increase verbosity"
    )
    args = parser.parse_args()
    gen_part_nv(args.file, args.dest, args.cut, verbose=args.verbose)


if __name__ == "__main__":
    main()
