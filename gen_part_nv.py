#!/usr/bin/env python3
"""
gen_part_nv.py [spfile]
A module for generating spX-part.nv fileoutput from spX.nv files.
"""
import sys
import os
import re

# used for constructing the graph (doing it again in Python seems silly, but it's easy!)
import igraph

# Orientation of partition
HORIZONTAL = True
VERTICAL = False

# Group
CORE = 0
AGGREGATION = 1
EDGE = 2


def cross_partition(e):
    (u, v) = e.vertex_tuple
    return (u["g"] == CORE and v["g"] == AGGREGATION) or (
        u["g"] == AGGREGATION and v["g"] == CORE
    )


def to_grp(name):
    if name == "core":
        return CORE
    elif name == "aggregation":
        return AGGREGATION
    elif name == "edge":
        return EDGE
    else:
        raise Exception("group name not recognized!")


def construct_graph(text):
    """
    Construct a digraph from the given edge and node information.
    """
    g = igraph.Graph(directed=True)
    for (v, grp) in find_nodes(text):
        g.add_vertex(g=grp)
    g.add_edges(find_edges(text))
    return g


def find_edges(text):
    """Return the edges."""
    prog = re.compile(
        r"(\d*)-(\d*); "
        r"\(\*(core|aggregation|edge)-\d*,Serial\d* --> (core|aggregation|edge)-\d*,Serial\d*\*\)"
    )
    matches = prog.finditer(text)
    outputs = [(int(match.group(1)), int(match.group(2))) for match in matches]
    outputs.sort()
    return outputs


def find_nodes(text):
    """Return the nodes."""
    prog = re.compile(r"(core|aggregation|edge)-\d*=(\d*)")
    # find all nodes
    matches = prog.finditer(text)
    vertices = [(int(match.group(2)), to_grp(match.group(1))) for match in matches]
    vertices.sort()
    return vertices


def write_preamble(spname, orientation=HORIZONTAL):
    """
    Return the string representation of the preamble.
    """
    vim_modeline = "(* vim: set syntax=ocaml: *)"
    oriented = "Vertically" if orientation else "Horizontally"
    file_info = f"(* {oriented} partitioned version of {spname} *)"
    generated_by = "(* Automatically generated by gen_part.nv.py *)"
    include_utils = 'include "../../../examples/utils.nv"'
    include_sp = 'include "{}"'.format(spname)
    return "\n".join([vim_modeline, file_info, generated_by, include_utils, include_sp])


def write_partition_str(nodes):
    """
    Return the string representation of the partition function.
    """
    output = "let partition node = match node with\n"
    output += "\n".join([f"  | {node}n -> 0u8" for node in nodes])
    output += "\n  | _ -> 1u8\n"
    return output


def write_interface_str(cross_edges):
    """
    Return the string representation of the interface function.
    """
    output = "let interface edge =\n"
    common_block = """match x with
      | { connected = c; static = s; ospf = o; bgp = b; selected = sel } ->
        c = None && s = None && o = None"""
    anyb = """  let any x = true
    in
    """
    nbb = """let nothingButBgp x =
      {}
    in
    """.format(
        common_block
    )
    hob = """let hasOnlyBgp x =
      {} && isSome b && sel = Some 3u2
    in
    """.format(
        common_block
    )
    output += anyb + nbb + hob
    output += "match edge with\n"
    for (start, end) in cross_edges:
        output += "  | {}~{} -> Some any\n".format(start, end)
    output += "  | _ -> None\n"
    return output


def get_part_fname(spfile, orientation=HORIZONTAL):
    """Return the name of the partition file for the corresponding spX.nv file."""
    spdir, spname = os.path.split(spfile)
    root, nvext = os.path.splitext(spname)
    part_suffix = "-part" if orientation else "-vpart"
    partfile = os.path.join(spdir, root + part_suffix + nvext)
    suffix = 1
    # don't overwrite an existing path: instead, create a new file
    while os.path.exists(partfile):
        partfile = os.path.join(spdir, root + part_suffix + str(suffix) + nvext)
        suffix += 1
    return partfile


def nodes_cut_vertically(graph):
    """Return half of the spine nodes and half of the pods."""
    spines = [v for v in graph.vs.select(g_eq=CORE)]
    half_spines = spines[: (len(spines) // 2)]
    aggs = [v for v in graph.vs.select(g_eq=AGGREGATION)]
    half_aggs = aggs[: (len(aggs) // 2)]
    # use a set so as not to add twice
    pods = set()
    for v in half_aggs:
        pods.add(v.index)
        for u in v.neighbors():
            if u["g"] == EDGE:
                pods.add(u.index)
    # return half of the spines along with the pods
    return [x.index for x in half_spines] + list(pods)


def validate(spine_nodes, cross_edges):
    """Validate that every cross edge goes to or from a spine node."""
    for (start, end) in cross_edges:
        if start not in spine_nodes and end not in spine_nodes:
            print(
                f"Warning: Edge {start},{end} does not appear to connect to the spine!"
            )


def gen_part_nv(spfile, orientation=HORIZONTAL, verbose=False):
    """Generate the partition file."""
    part = get_part_fname(spfile, orientation)
    if verbose:
        print("Outfile: " + part)
    with open(spfile, "r") as inputfile:
        sptext = inputfile.read()
    # compute the graph topology
    graph = construct_graph(sptext)
    if verbose:
        print(str(graph))
    # get the three parts
    preamble = write_preamble(os.path.basename(spfile))
    if orientation:
        cross_edges = [e.tuple for e in graph.es if cross_partition(e)]
        nodes = [v.index for v in graph.vs if v["g"] == CORE]
    else:
        nodes = nodes_cut_vertically(graph)
        nodes.sort()
        cross_edges = [
            e.tuple
            for e in graph.es
            # check that the edge crosses out of the nodes we found
            if (e.source in nodes and e.target not in nodes)
            or (e.target in nodes and e.source not in nodes)
        ]
    # validate spine and cross edges
    validate(nodes, cross_edges)
    if verbose:
        print(nodes)
        print(cross_edges)
    partition = write_partition_str(nodes)
    interface = write_interface_str(cross_edges)
    # put 'em all together
    output = "\n".join([preamble, partition, interface])
    with open(part, "w") as outfile:
        outfile.write(output)


if __name__ == "__main__":
    INPUT = sys.argv[1]
    ORIENT = sys.argv[2]
    if ORIENT == "h":
        gen_part_nv(INPUT, HORIZONTAL)
    elif ORIENT == "v":
        gen_part_nv(INPUT, VERTICAL)
    else:
        print("Invalid orientation given!")
