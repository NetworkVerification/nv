"""
Utilities for generating Topology Zoo benchmarks.
"""
from enum import Enum
from typing import Iterable, Optional, Any
import igraph
import os
import sys

# TODO: use this
class ASRelationship(Enum):
    CUST_PROV = "cust_prov"
    PEER_PEER = "peer_peer"
    PROV_CUST = "prov_cust"


class NvFile:
    def __init__(self, name):
        self.name = name
        self.types = []
        self.symbolics = []
        self.requires = []
        self.consts = []
        self.funcs = []
        self.sols = []
        self.asserts = []

    def add_type(self, tname, ty_exp):
        self.types.append(f"type {tname} = {ty_exp}")

    def add_topology(self, nodes: int, edges, names=None):
        """
        Add the topology.
        If names is given, the edges should be names; otherwise they should be node indices.
        """
        if names is not None:
            node_list = comment(
                "{" + ", ".join([f"{name}={i}" for (name, i) in names.items()]) + "}"
            )
            self.asserts.append(node_list)
        self.consts.append(f"let nodes = {nodes}")
        edge_list = "\n  ".join(
            [
                f"{u}={v};"
                if names is None
                else f"{names[u]}={names[v]}; (*{u} <--> {v}*)"
                for (u, v) in undirected(edges)
            ]
        )
        self.consts.append(f"let edges = {{\n  {edge_list}\n}}")

    def add_symb(self, name, ty):
        self.symbolics.append(f"symbolic {name} : {ty}")

    def add_req(self, exp):
        self.requires.append(f"require {exp}")

    def add_let(self, fname, args, fbody):
        if len(args) > 0:
            argstr = " ".join(args)
            self.funcs.append(f"let {fname} {argstr} = {fbody}")
        else:
            self.consts.append(f"let {fname} = {fbody}")

    def add_solution(self, var):
        self.sols.append(
            f"let {var} = solution {{ init = init; trans = trans; merge = merge; }}"
        )

    def add_assert(self, exp):
        self.asserts.append(f"assert {exp}")

    def __str__(self):
        s = ""
        s += comment(f"Generated by {os.path.basename(__file__)}") + "\n\n"
        s += "\n\n".join(
            self.types
            + self.consts
            + self.symbolics
            + self.requires
            + self.funcs
            + self.sols
            + self.asserts
        )
        return s


def from_relns(relns_file: str):
    """
    Import a topology and relationships from a relns.txt file.
    The file should be evaluated as a Python dictionary,
    where the keys are tuple[str,str] and the values are one of
    'prov_cust', 'peer_peer' and 'cust_prov'.
    """
    with open(relns_file, "r") as relns_text:
        t = relns_text.read()
        relns: dict[tuple[str, str], str] = eval(t)
    edges = relns.keys()
    nodes = set(x for l in [[u, v] for (u, v) in edges] for x in l)
    name_to_node = {name: i for (i, name) in enumerate(nodes)}
    # edge_list = [(name_to_node[u], name_to_node[v]) for (u, v) in edges]
    business_rel = {
        (name_to_node[u], name_to_node[v]): rel for ((u, v), rel) in relns.items()
    }
    return len(nodes), edges, business_rel, name_to_node


def from_graphml(graphml_file: str):
    """Import a network topology from a GraphML file."""

    def node_to_name(u: igraph.Vertex):
        return f"{u['label']},{int(u['id'])}"

    g = igraph.Graph.Read_GraphML(graphml_file)
    # if any multi-edges are in the graph, combine them
    g.simplify(combine_edges=dict(id=lambda edges: ", ".join(edges)))
    edges = []
    for e in g.es:
        u, v = e.vertex_tuple
        edges.append((node_to_name(u), node_to_name(v)))
    name_to_node = {node_to_name(u): u.index for u in g.vs}
    return g.vcount(), edges, None, name_to_node


def comment(s: str) -> str:
    """Return an OCaml comment containing the given string s."""
    return "(* " + s + " *)"


def pattern(x):
    if isinstance(x, tuple) and len(x) == 2:
        return f"{x[0]}~{x[1]}"
    else:
        return str(x)


def dict_to_match(d: dict, exp):
    branches = "\n".join([f"| {pattern(pat)} -> {body}" for (pat, body) in d.items()])
    return f"match {exp} with\n{branches}"


def undirected(directed: Iterable[tuple[Any, Any]]):
    """Convert a list of directed edges to undirected edges."""
    return [(u, v) for (u, v) in directed if u < v]


def node_to_int(nodes: int, node_exp) -> str:
    """Create a match statement mapping nodes to integers."""
    return dict_to_match({f"{n}n": n for n in range(nodes)}, node_exp)


def stubs(nodes, relns) -> list[int]:
    """Return the list of stub nodes."""
    # start from every node, drop any node that is ever a peer or a provider
    stubs = set(range(0, nodes))
    for ((u, v), relp) in relns.items():
        if relp == "cust_prov":
            stubs.discard(v)
        elif relp == "peer_peer":
            stubs.discard(u)
            stubs.discard(v)
        elif relp == "prov_cust":
            stubs.discard(u)
    return list(stubs)


def to_nv(
    net_name: str,
    nodes: int,
    edges: Iterable[tuple[Any, Any]],
    business_rel: Optional[dict],
    names: Optional[dict[str, int]],
    symb=False,
) -> str:
    """
    Create an NV file.
    If business_rel is not None, the policy should enforce no-transit; otherwise, it should
    be a shortest-paths policy.
    """
    f = NvFile(f"{net_name}.nv")
    f.add_type("bgpType", "{bgpAd: int; lp: int; aslen: int; med:int; comms:set[int];}")
    f.add_type("attribute", "option[bgpType]")

    f.add_topology(nodes, edges, names)

    if business_rel:
        relp_body = dict_to_match(business_rel, "e")
        f.add_let("cust_prov", [], 0)
        f.add_let("peer_peer", [], 1)
        f.add_let("prov_cust", [], 2)
        f.add_let("relationship", ["e"], relp_body)

    # init
    if symb:
        f.add_symb("d", "int")
        if business_rel:
            # require that d is not a provider
            allowed_nodes = " || ".join(
                [f"d = {v}" for v in stubs(nodes, business_rel)]
            )
            f.add_req(allowed_nodes)
        f.add_req(f"d < {nodes}")
        f.add_let("node_to_int", ["n"], node_to_int(nodes, "n"))
        cond = "(node_to_int n) = d"
    else:
        cond = "n = 2n"
    f.funcs.append(
        f"let init n = if {cond} then Some {{ bgpAd = 0; lp = 100; aslen = 0; med = 0; comms = {{}} }} else None"
    )

    # merge
    f.funcs.append(
        r"""let pickOption f x y =
  match (x,y) with
  | (None, None) -> None
  | (None, Some _) -> y  | (Some _, None) -> x
  | (Some a, Some b) -> Some (f a b)

let betterBgp b1 b2 =
  if b1.lp > b2.lp then b1
  else if b2.lp > b1.lp then b2
  else if b1.aslen < b2.aslen then b1
  else if b2.aslen < b1.aslen then b2  else if b1.med >= b2.med then b1 else b2

let mergeBgp x y = pickOption betterBgp x y

let merge n x y = mergeBgp x y"""
    )

    # transfer
    if business_rel:
        f.funcs.append(
            r"""(* We add community tags to designate providers, peers and customers,
* and use these tags to adjust local preference.
* We also need to identify when an edge is to a provider or a peer,
* in which case if the route is tagged as from a customer then it
* should be dropped.
* The relationship(a~b) edge function returns:
* - cust_prov if a is a customer of b (b is a provider for a)
* - peer_peer if a is a peer of b (should be symmetric)
* - prov_cust if a is a provider for b (b is a customer of a)
* A node v will only advertise a route from its neighbor u to another neighbor w according to the following rules:
* if relationship(uv) = customer, v will advertise the route to w;
* if relationship(uv) = peer or relationship(uv) = prov, v will only advertise the route to w if relationship(vw) = cust
*)
let transferBgp e x =
match x with
| None -> None
| Some b -> (
    (* enforce no transit: if the route is neither from a customer nor to a customer, then drop it;
    * don't use !(b.comms[cust_prov]) since by default b.comms starts empty
    *)
    if (b.comms[peer_peer] || b.comms[prov_cust]) && !(relationship e = prov_cust) then None else
    (* update LP *)
    let lp = if (relationship e = cust_prov) then 200
        else if (relationship e = peer_peer) then 100
        else 0
    in
    (* update comms: mark the source of the message and remove old relationship tags *)
    let comms = if (relationship e = cust_prov) then b.comms[cust_prov := true][peer_peer := false][prov_cust := false]
        else if (relationship e = peer_peer) then b.comms[peer_peer := true][cust_prov := false][prov_cust := false]
        else b.comms[prov_cust := true][cust_prov := false][peer_peer := false]
    in
    let b = {b with comms = comms; aslen = b.aslen + 1; lp = lp} in
    Some b
)

let trans e x = transferBgp e x"""
        )
    else:
        f.funcs.append(
            r"""(* Simple shortest-path routing. *)
let transferBgp e x =
  match x with
  | None -> None
  | Some b -> Some {b with aslen = b.aslen + 1}

let trans e x = transferBgp e x"""
        )
    f.add_let("assert_node", ["u", "v"], "match v with | None -> false | _ -> true")
    f.add_solution("sol")
    f.add_assert("foldNodes (fun u v acc -> acc && assert_node u v) sol true")
    return str(f)


def to_hgr(nodes, edges):
    preamble = (
        f"% generated from {os.path.basename(__file__)}\n"
        "% number of edges; number of vertices\n"
        f"% note vertex numbering starts from 1, so 0 is remapped to {nodes}"
    )
    # convert from directed to undirected, then
    # remap 0 to the max node to start numbering from 1
    edges = [
        (u if u > 0 else nodes, v if v > 0 else nodes) for (u, v) in undirected(edges)
    ]
    edge_list = "\n".join([f"{u} {v}" for (u, v) in edges])
    totals = f"{len(edges)} {nodes}"
    return "\n".join([preamble, totals, edge_list])


def to_dot(name, edges):
    preamble = f"// generated from {os.path.basename(__file__)}"
    # convert from directed to undirected
    edges = undirected(edges)
    edge_list = "\n".join([f"  {u} -- {v};" for (u, v) in edges])
    return "\n".join([preamble, f"graph {name} {{", edge_list, "}"])


if __name__ == "__main__":
    input_file = sys.argv[1]
    net_dir, net_file = os.path.split(input_file)
    if net_file.endswith(".graphml"):
        net_name = net_file.removesuffix(".graphml")
        nodes, edges, business_rel, names = from_graphml(input_file)
    elif net_file.endswith("_relns.txt"):
        # get the name of the network from the relns file
        net_name = net_file.removesuffix("_relns.txt")
        nodes, edges, business_rel, names = from_relns(input_file)
    else:
        raise Exception(
            "Expected first argument to be a .graphml file or a _relns.txt file."
        )
    match sys.argv[2:]:
        case ["nv", s, *_]:
            symb = s == "-s" or s == "--symbolic"
            print(to_nv(net_name, nodes, edges, business_rel, names, symb))
        case ["hgr", *_]:
            if names is not None:
                edges = [(names[u], names[v]) for (u, v) in edges]
            print(to_hgr(nodes, edges))
        case ["dot", *_]:
            if names is not None:
                edges = [(names[u], names[v]) for (u, v) in edges]
            print(to_dot(net_name, edges))
