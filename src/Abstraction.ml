open Graph
open AbstractionMap
open Unsigned
open Console
open Srp
open Hashtbl
open Syntax
open BatSet

let debugAbstraction = ref true


module Slice =
  struct
    type prefix = Unsigned.UInt32.t * Unsigned.UInt32.t
                
    let get_prefixes_from_val (dictv : Syntax.value) : prefix list =
      match dictv.v with
      | VMap dict ->
         List.map (fun (prefixv, _) ->
             match prefixv.v with
             | VTuple [ipv; prev] ->
                (match ipv.v, prev.v with
                 | VUInt32 ip, VUInt32 pre -> (ip, pre)
                 | _, _ -> failwith "not a concrete prefix")
             | _ -> failwith "expected a tuple") (fst (BddMap.bindings dict))
      | _ -> failwith "value is not a dict"
           
    let build_prefix_map (u : Unsigned.UInt32.t)
                         (prefixes: prefix list)
                         (acc : (prefix, Graph.VertexSet.t) BatMap.t):
          (prefix, Graph.VertexSet.t) BatMap.t =
      List.fold_left (fun acc pre ->
          BatMap.modify_def Graph.VertexSet.empty pre
                            (fun us -> Graph.VertexSet.union (Graph.VertexSet.singleton u) us)
                            acc) acc prefixes
      
    (* Slices the network, creating multiple networks where only one
       node originates some message.
       Currently this will only work with networks generated by batfish and
       init_functions that do not include symbolic values. *)
    let slice_network (g: Graph.t) (init : Syntax.exp) =
      Graph.fold_vertices
        (fun u acc -> let dict_exp = Interp.interp (Syntax.apps init [e_val (vint u)]) in
                      let prefixes = get_prefixes_from_val dict_exp in
                      build_prefix_map u prefixes acc) g BatMap.empty
  end

(** Sets of Abstract Nodes *)
module AbstractNodeSet : Set.S with type elt := AbstractNode.t = Set.Make(AbstractNode)

(** Sets of Abstract Node Ids *)
type absIdSet = abstrId BatSet.t

(** transfer hash, abstract id *)
type transAbsId = int * abstrId

(** merge_hash * {(trans_hash, abstractId)}*) 
type policyAbsId = int * (transAbsId BatSet.t)
                                                               
(** Given a map from vertices to elements of type 'a, returns the sets
   of vertices that map to the same elements.  *)     
let groupKeysByValue (umap: 'a VertexMap.t) : AbstractNodeSet.t =
  let reverseMap : ('a, AbstractNode.t) BatMap.t =
    VertexMap.fold (fun u vhat acc ->
        BatMap.modify_opt vhat (fun us -> match us with
                                              | None -> Some (AbstractNode.singleton u)
                                              | Some us -> Some (AbstractNode.add u us)) acc)
                   umap BatMap.empty in
  BatMap.fold (fun v acc -> AbstractNodeSet.add v acc)
                      reverseMap AbstractNodeSet.empty

(** ** Topological only abstraction *)
(* This does not handle a forall-forall abstraction. *)  
let refineTopological (f: abstractionMap) (g: Graph.t)
                      (us: AbstractNode.t) : abstractionMap =
  let refineOne (u : Vertex.t) (umap : absIdSet VertexMap.t) =
    List.fold_left (fun acc v ->
        let vhat = getId f v in
        VertexMap.update u (fun omapu ->
                           match omapu with
                           | None -> Some (BatSet.singleton vhat)
                           | Some vs -> Some (BatSet.add vhat vs)) acc) umap
                   (neighbors g u)
  in
  let vmap = AbstractNode.fold (fun u acc -> refineOne u acc) us VertexMap.empty in
  AbstractNodeSet.fold (fun us f' -> AbstractionMap.split f' us) (groupKeysByValue vmap) f

let rec abstractionTopological (f: abstractionMap) (g: Graph.t) : abstractionMap =
  let f' = AbstractionMap.fold (fun _ us facc ->
               if (VertexSet.cardinal us > 1) then
                 refineTopological facc g us 
               else
                 facc) f f in
  if (size f = size f') then normalize f' 
  else abstractionTopological f' g

(** * Proper policy+topology abstraction *)  
 
let refineAbstraction (f: abstractionMap) (g: Graph.t)
                      (transMap: (Edge.t, int * Syntax.exp) Hashtbl.t)
                      (mergeMap: (Vertex.t, int * Syntax.exp) Hashtbl.t)
                      (us: AbstractNode.t) : abstractionMap =
  let refineOne (u : Vertex.t) (umap : policyAbsId VertexMap.t) =
    List.fold_left (fun acc v ->
        let vhat = getId f v in
        let (trans_pol, _) = Hashtbl.find transMap (u,v) in
        VertexMap.update u (fun omapu ->
            match omapu with
            | None ->
               let (merge_pol, _) = Hashtbl.find mergeMap u in
               Some (merge_pol, BatSet.singleton (trans_pol, vhat))
            | Some (mp, vs) ->
               Some (mp, BatSet.add (trans_pol, vhat) vs))
                         acc) umap (neighbors g u)
  in
  (* for each node u in us, find the (abstract) nodes it's connected to and their policy *)
  let vmap = AbstractNode.fold (fun u acc -> refineOne u acc) us VertexMap.empty in
  AbstractNodeSet.fold (fun us f' -> AbstractionMap.split f' us) (groupKeysByValue vmap) f

let rec abstraction (f: abstractionMap) (g: Graph.t)
                    (transMap: (Edge.t, int * Syntax.exp) Hashtbl.t)
                    (mergeMap: (Vertex.t, int * Syntax.exp) Hashtbl.t) : abstractionMap =
  let f' = AbstractionMap.fold (fun _ us facc ->
               if (VertexSet.cardinal us > 1) then
                 refineAbstraction facc g transMap mergeMap us 
               else
                 facc) f f in
  if (size f = size f') then normalize f' 
  else abstraction f' g transMap mergeMap

let partialEvalTrans (graph : Graph.t)
                     (trans : Syntax.exp) : (Edge.t, int * Syntax.exp) Hashtbl.t  =
  let edge_to_val e = vtuple [vint (fst e); vint (snd e)] in
  let es = Graph.edges graph in
  let tbl = Hashtbl.create (List.length es) in
  List.iter (fun e ->
      (* remove unused variables from closures before hashing transfer functions *)
      (* Printf.printf "%s\n" *)
      (*               (Syntax.show_exp ~show_meta:false *)
      (*                                   (exp_of_value (vclosure (network.trans)))); *)
      let ptrans = Interp.interp_partial_fun trans [edge_to_val e] in
      Printf.printf "edge (%d,%d): %s\n" (UInt32.to_int (fst e)) (UInt32.to_int (snd e))
      (Syntax.show_exp ~show_meta:false ptrans);
      Hashtbl.add tbl e ((Syntax.hash_exp ~hash_meta:false ptrans), ptrans)) es;
  tbl

let partialEvalMerge (graph : Graph.t)
                     (merge : Syntax.exp) : (Vertex.t, int * Syntax.exp) Hashtbl.t =
  let node_to_val n = vint n in
  let ns = Graph.get_vertices graph in
  let tbl = Hashtbl.create (VertexSet.cardinal ns) in
  VertexSet.iter (fun v ->
      let pmerge = Interp.interp_partial_fun merge [node_to_val v] in
      Hashtbl.add tbl v (Syntax.hash_exp ~hash_meta:false pmerge, pmerge)) ns;
  tbl


(* Given a concrete graph g, an abstraction function f and an abstract
   node id returns its abstract edges *)
let findAbstractEdges (g: Graph.t) (f: abstractionMap) (uhat: abstrId) : Edge.t list =
  let repru = getGroupRepresentativeId f uhat in
  let ns = neighbors g repru in
  List.map (fun v -> uhat, getId f v) ns

(* Deprecated right now *)
let addAbstractEdges (g: Graph.t) (f: abstractionMap) (ag: Graph.t)
                     (uhat: abstrId) : Graph.t =
  add_edges ag (findAbstractEdges g f uhat)

(* Requires that abstract group ids are contiguous. *)
let buildAbstractGraph (g: Graph.t) (f: abstractionMap) : Graph.t =
  let ag = Graph.create (UInt32.of_int (size f)) in
  VertexSet.fold (fun uhat acc -> addAbstractEdges g f acc uhat) (get_vertices ag) ag   

(* Given a concrete graph and an abstraction function returns the node
   and edges of the abstract graph *)
let buildAbstractGraphDecls (g: Graph.t) (f: abstractionMap) : UInt32.t * (Edge.t list) =
  let n = UInt32.of_int (size f) in
  let rec edges uhat =
    if uhat = n then []
    else (findAbstractEdges g f uhat) @ edges (UInt32.add uhat UInt32.one)
  in
  (n, edges UInt32.zero)

(* Helper function that constructs an MGet expression *)
let mget (m : exp) (i : exp) : exp =
  eop MGet [m; i]
  
let buildSymbolicFailures (edges : Edge.t list) (k : int) (failuresVar : Var.t) =
  (* symbolic map of failures *)
  let failuresMap = e_val (vmap (BddMap.create ~key_ty:tint (vbool false))) in
  let bool2int_exp arg = eif arg (e_val (vint UInt32.one)) (e_val (vint UInt32.zero)) in
  let failuresSum = List.fold_left (fun acc (uhat, vhat) ->
                     eop UAdd [(bool2int_exp (mget (evar failuresVar)
                                         (e_val (vtuple [vint uhat; vint vhat])))); acc])
                                (e_val (vint UInt32.zero)) edges in
  let failures_leq_k = eop ULeq [failuresSum; e_val (vint (UInt32.of_int k))] in
  [DRequire failures_leq_k; DSymbolic (failuresVar, Exp failuresMap)]
  
  
(* Given the abstract edges and a concrete transfer function, 
   synthesizes an abstract transfer function. *)
let buildAbstractTrans (aedges : Edge.t list)
                       (trans: (Edge.t, int * Syntax.exp) Hashtbl.t)
                       (failuresVar : Var.t)
                       (f: abstractionMap) : Syntax.exp =
  (* edge argument used by abstract transfer function *)
  let aedge_var = Var.create "edge" in
 
  (* code that implements check for failed edge *)
  let failCheck exp = eif (mget (evar failuresVar) (evar aedge_var))
                          (exp_of_value (voption None))
                          exp in
  
  (* inserting that code in the body of the transfer function *)
  let addFailureCheck exp =
    match exp.e with
    | EFun f ->
       failCheck f.body
    | _ -> failwith "expected a function"
  in

  (* for each abstract edge, find it's corresponding concrete
     transfer function and augment it with a check for whether it's
     failed *)
  let branches =
    List.fold_left (fun acc (uhat, vhat) ->
        let p = PTuple [PUInt32 uhat; PUInt32 vhat] in
        let (u,v) = (getGroupRepresentativeId f uhat, getGroupRepresentativeId f vhat) in
        let (_, transuv) = Hashtbl.find trans (u,v) in
        (p, addFailureCheck transuv) :: acc) [] aedges
  in
  (* partial evaluted trans functions are of the form fun m -> ..., grab m *)
  let messageArg = match aedges with
    | [] -> failwith "No edges found"
    | (uhat, vhat) :: _ ->
       let uv = (getGroupRepresentativeId f uhat, getGroupRepresentativeId f vhat) in
       let (_, transuv) = Hashtbl.find trans uv in
       match transuv.e with
       | EFun f ->
          f.arg
       | _ -> failwith "expected a function"
  in
  let match_exp = ematch (evar aedge_var) branches in
  (* create fun m -> trans_hat_body *)
  let trans_hat_msg = Syntax.lam messageArg match_exp in
  (*return fun e_hat m -> trans_hat_body *)  
  Syntax.lam aedge_var trans_hat_msg

(* Given the number of abstract nodes and a concrete merge function, 
   synthesizes an abstract merge function. *)
let buildAbstractMerge (n : UInt32.t)
                       (merge: (Vertex.t, int * Syntax.exp) Hashtbl.t)
                       (f: abstractionMap) : Syntax.exp =
  (* vertex argument used by abstract merge function *)
  let avertex_var = Var.create "node" in
  
  (* for each abstract node, find it's corresponding concrete
      merge function. *)
  let rec branches uhat =
    if uhat = n then []
    else
      let p = PUInt32 uhat in
      let u = getGroupRepresentativeId f uhat in
      let (_, mergeu) = Hashtbl.find merge u in
      (p, mergeu) :: (branches (UInt32.add uhat UInt32.one))
  in
  (* create a match on the node expression *)
  let match_exp = ematch (evar avertex_var) (branches UInt32.zero) in
  (*return fun uhat m -> merge_hat_body *)  
  Syntax.lam avertex_var match_exp


(* Given an abstraction function, a concrete graph, transfer and merge
   function, and the number of maximum link failures builds an
   abstract network *)
let buildAbstractNetwork (f: abstractionMap) (graph: Graph.t)
                         (mergeMap: (Vertex.t, int * Syntax.exp) Hashtbl.t)
                         (transMap : (Edge.t, int * Syntax.exp) Hashtbl.t)
                         (k : int) : declarations =
  (* build the abstract graph based on the abstraction function *)
  let (n, edgeshat) = buildAbstractGraphDecls graph f in
  (* create a variable to point to a failures map *)
  let failuresVar = Var.create "fail" in
  (* build the abstract merge function *)
  let mergehat = buildAbstractMerge n mergeMap f in
  (* build the abstract transfer function *)
  let transhat = buildAbstractTrans edgeshat transMap failuresVar f in
  (* build the symbolic representation of failures *) 
  let symbolics = buildSymbolicFailures edgeshat k failuresVar in
  (DNodes n) :: (DEdges edgeshat) :: (DMerge mergehat) :: (DTrans transhat) :: symbolics

  
(* Given a concrete graph, transfer, merge functions a destinations
   computes an abstract network *)
let findAbstraction (graph: Graph.t) (trans : Syntax.exp)
                    (merge : Syntax.exp) (d: Vertex.t) (k : int) : abstractionMap =
  let f = AbstractionMap.split (createAbstractionMap graph) (VertexSet.singleton d) in
  let transMap = partialEvalTrans graph trans in
  let mergeMap = partialEvalMerge graph merge in
  (* compute the abstraction function *)
  let f = abstraction f graph transMap mergeMap in
  f
  
let abstractToConcreteEdge (g: Graph.t) (f: abstractionMap) (ehat: Edge.t) : EdgeSet.t =
  let (uhat, vhat) = ehat in
  let us = getGroupById f uhat in (* get nodes represented by uhat *)
  let getNeighborsInVhat u =
    BatList.filter_map (fun v ->
        if (getId f v = vhat) then Some (u,v) else None) (neighbors g u)
    |> EdgeSet.of_list
  in
  AbstractNode.fold
    (fun u acc -> EdgeSet.union (getNeighborsInVhat u) acc) us EdgeSet.empty
  
let getEdgeMultiplicity (g: Graph.t) (f: abstractionMap) (ehat: Edge.t) : int =
  EdgeSet.cardinal (abstractToConcreteEdge g f ehat)
  
(* For failures we don't really need to care about the policies when
   computing a new abstraction as those have already been factored in
   and we are only splitting things. We just have to ensure a
   topological abstraction (forall-exists). *)
module FailuresAbstraction =
  struct
    type splittings = Mesh | Groups of AbstractNodeSet.t

    (* For each abstract node [uhat] and [vhat], partitions the concrete
       nodes in uhat into subsets s.t. that nodes in the same subset have
       edges to the same concrete nodes in [vhat] *)                              
    let splitForFailures (uhat : AbstractNode.t) (vhat : AbstractNode.t)
                         (g: Graph.t) : splittings = 
      let addNeighbor u =
        let neighborsOfu = neighbors g u in
        let neighborsOfUinV = List.filter (fun v -> AbstractNode.mem v vhat) neighborsOfu in
        AbstractNode.of_list neighborsOfUinV
      in
      let connectivityMap = AbstractNode.fold (fun u acc ->
                                VertexMap.add u (addNeighbor u) acc) uhat VertexMap.empty in
      let us = groupKeysByValue connectivityMap in
      if ((AbstractNodeSet.cardinal us) = 1) then
        Mesh
      else
        Groups us

    (* using the abstract group id on path for efficiency reasons *)
    (* - assumes uid can be split
       - returns a random split with maximum ratio if the path was empty
       - returns a random split with ratio 1.0 if you immediately get to a full mesh.
       TODO: no need to return a ratio of 1.0, do max_int. Also avoid enforcing invariants
       with the ratio *)
    let bestSplitForFailures (g : Graph.t) (f: abstractionMap)
                             (uid: abstrId) (path: abstrId list) =
      let rec loop path current best =
        match path with
        | [] -> best
        | vid :: path ->
           let curGroup = getGroupById f current in
           match splitForFailures curGroup (getGroupById f vid) g with
           | Groups us when AbstractNodeSet.cardinal us = 2 ->
              (us, 0.0)
           | Groups us ->
              let szNew = AbstractNodeSet.cardinal us in
              let szCur = AbstractNode.cardinal curGroup in
              let ratio = (float_of_int szNew) /. (float_of_int szCur) in
              (* heuristic *)
              if (ratio < snd best) then
                loop path vid (us, ratio)
              else
                loop path vid best
           | Mesh ->
              (* do a randomSplit if necessary, but maybe there are better options*)
              if (snd best) > 1.0 then
                let u1, u2 = AbstractNode.randomSplit curGroup in
                (AbstractNodeSet.of_list [u1;u2], 1.0)
              else
                best
      in
      let u1, u2 = AbstractNode.randomSplit (getGroupById f uid) in
      loop path uid (AbstractNodeSet.of_list [u1;u2], float_of_int max_int)


    let splitSet_debug us =
      if !debugAbstraction then
        show_message (AbstractNode.printAbstractNode us) T.Blue "splitting set"
      
    (* Repeatedly split to create the abstract nodes in [uss] *)
    let splitSet f (uss : AbstractNodeSet.t) : abstractionMap =
      AbstractNodeSet.fold
        (fun us f' -> splitSet_debug us; AbstractionMap.split f' us) uss f

    let refineForFailures_debug (f: abstractionMap) =
      if !debugAbstraction then
        show_message (printAbstractGroups f "\n") T.Blue
                     "Abstract groups after refine for failures "
      
    let refineForFailures (g: Graph.t) (f: abstractionMap)
                          (uid: abstrId) (path: abstrId list) : abstractionMap =
      let (uss, _) = bestSplitForFailures g f uid path in
      let f' = splitSet f uss in
      let f'' =  abstractionTopological f' g in
      refineForFailures_debug f'';
      f''
      
  end
