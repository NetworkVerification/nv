open Syntax

type network =
  { attr_type : Syntax.ty;
    init      : Syntax.exp;
    trans     : Syntax.exp;
    merge     : Syntax.exp;
    assertion : Syntax.exp;
    graph     : Graph.t;
  }
   
type prefix = Unsigned.UInt32.t * Unsigned.UInt32.t

let partialEvalOverNodes (g : Graph.t) (e: Syntax.exp) =
  let tbl = Hashtbl.create (Unsigned.UInt32.to_int (Graph.num_vertices g)) in
  Graph.fold_vertices
    (fun u _ ->
      let initu = Interp.interp_partial (Syntax.apps e [e_val (vint u)]) in
      Hashtbl.add tbl u initu) g ();
  tbl
            
let get_prefixes_from_val (dictv : Syntax.value) : prefix list =
  match dictv.v with
  | VMap dict ->
     List.map (fun (prefixv, _) ->
         match prefixv.v with
         | VTuple [ipv; prev] ->
            (match ipv.v, prev.v with
             | VUInt32 ip, VUInt32 pre -> (ip, pre)
             | _, _ -> failwith "not a concrete prefix")
         | _ -> failwith "expected a tuple") (fst (BddMap.bindings dict))
  | _ -> failwith "value is not a dict"
       
let build_prefix_map (u : Unsigned.UInt32.t)
                     (prefixes: prefix list)
                     (acc : (prefix, Graph.Vertex.t BatSet.t) BatMap.t):
      (prefix, Graph.Vertex.t BatSet.t) BatMap.t =
  List.fold_left (fun acc pre ->
      BatMap.modify_def BatSet.empty pre
                        (fun us -> BatSet.union (BatSet.singleton u) us)
                        acc) acc prefixes

let relevantPrefixes_exp (e: Syntax.exp) =
  let prefixes = ref BatSet.empty in 
  let attru, bodyu =
    match e.e with
    | EFun f -> f.arg, f.body
    | _ -> failwith "assertion must be a function"
  in
  Visitors.iter_exp (fun e ->
      match e.e with
      | EOp (MGet, [e1;e2]) when is_value e2 ->
         (match (Syntax.to_value e2).v with
          | VTuple [v1;v2] ->
             (match v1.v, v2.v with
              | VUInt32 ip, VUInt32 p ->
                 prefixes := BatSet.add (ip, p) !prefixes
              | _ -> ())
          | _ -> ())
      | _ -> ()) bodyu;
  !prefixes
  
let relevantPrefixes (assertionTable : (Unsigned.UInt32.t, Syntax.exp) Hashtbl.t) =
  Hashtbl.fold (fun _ eu acc ->
      let prefixes = relevantPrefixes_exp eu in
      BatSet.union prefixes acc) assertionTable BatSet.empty

let partialEvalInit (n : network) =
  partialEvalOverNodes n.graph n.init

let partialEvalAssert (n : network) =
  partialEvalOverNodes n.graph n.assertion
  
(* Currently this will only work with networks generated by batfish and
       init_functions that do not include symbolic values, i.e.
       initu must be a value*)
let findInitialSlices initTbl =
  Hashtbl.fold
    (fun u initu acc ->
      if Syntax.is_value initu then 
        let prefixes = get_prefixes_from_val (Syntax.to_value initu) in
        build_prefix_map u prefixes acc
      else failwith "symbolic announcements are not supported (yet)") initTbl BatMap.empty

(* let sliceAssertion (prefixes : prefix BatSet.t) *)
(*                    (assertionTable : (Unsigned.UInt32.t, Syntax.exp) Hashtbl.t) = *)
  
