open Syntax
open Unsigned
open BatSet

type network =
  { attr_type : Syntax.ty;
    init      : Syntax.exp;
    trans     : Syntax.exp;
    merge     : Syntax.exp;
    assertion : Syntax.exp;
    graph     : AdjGraph.t;
  }
   
module Prefix =
  struct
    type t = Integer.t * Integer.t
    let compare = Pervasives.compare
  end

module PrefixSet = BatSet.Make(Prefix)
module PrefixSetSet = BatSet.Make(PrefixSet)
module PrefixMap = BatMap.Make(Prefix)
  
let printPrefix ((ip, pre) : Prefix.t) =
  Printf.sprintf "(%d, %d)" (Integer.to_int ip) (Integer.to_int pre)

let printPrefixes (prefixes : PrefixSet.t) =
  "{" ^ PrefixSet.fold (fun pre acc -> (printPrefix pre) ^ "," ^ acc) prefixes "}"
            
let partialEvalOverNodes (g : AdjGraph.t) (e: Syntax.exp) =
  let tbl = Hashtbl.create (Integer.to_int (AdjGraph.num_vertices g)) in
  AdjGraph.fold_vertices
    (fun u _ ->
      let initu = Interp.interp_partial (Syntax.apps e [e_val (vint u)]) in
      Hashtbl.add tbl u initu) (AdjGraph.num_vertices g) ();
  tbl

(* deprecated *)
(* let get_prefixes_from_val (dictv : Syntax.value) : Prefix.t list = *)
(*   match dictv.v with *)
(*   | VMap dict -> *)
(*      List.map (fun (prefixv, _) -> *)
(*          match prefixv.v with *)
(*          | VTuple [ipv; prev] -> *)
(*             (match ipv.v, prev.v with *)
(*              | VInt ip, VInt pre -> (ip, pre) *)
(*              | _, _ -> failwith "not a concrete prefix") *)
(*          | _ -> failwith "expected a tuple") (fst (BddMap.bindings dict)) *)
(*   | _ -> failwith "value is not a dict" *)

let build_prefix_map (u : Integer.t)
                     (prefixes: PrefixSet.t)
                     (acc : AdjGraph.VertexSet.t PrefixMap.t):
      AdjGraph.VertexSet.t PrefixMap.t =
  PrefixSet.fold (fun pre acc ->
      PrefixMap.modify_def AdjGraph.VertexSet.empty pre
                           (fun us -> AdjGraph.VertexSet.add u us) acc)
                 prefixes acc

(* Finds the prefixes used by an expression *)
let get_prefixes_from_expr (expr: Syntax.exp) : PrefixSet.t =
  let prefixes = ref PrefixSet.empty in
  Visitors.iter_exp (fun e ->
      match e.e with
      | EOp (UEq, [var; pre]) when is_value pre ->
         (match var.e with
          | EVar x ->
             if (Var.name x) = "d" then
               begin
                 match (Syntax.to_value pre).v with
                 | VTuple [v1;v2] ->
                    (match v1.v, v2.v with
                     | VInt ip, VInt p ->
                        prefixes := PrefixSet.add (ip, p) !prefixes
                     | _ -> ())
                 | _ -> ()
               end
             else ()
          | _ -> ())
      | _ -> ()) expr;
  !prefixes
  
let relevantPrefixes (assertionTable : (Integer.t, Syntax.exp) Hashtbl.t) =
  Hashtbl.fold (fun _ eu acc ->
      let prefixes = get_prefixes_from_expr eu in
      PrefixSet.union prefixes acc) assertionTable PrefixSet.empty

let partialEvalInit (n : network) =
  partialEvalOverNodes n.graph n.init

let partialEvalAssert (n : network) =
  partialEvalOverNodes n.graph n.assertion
  
(* Currently this will only work with networks generated by batfish. *)
let findInitialSlices initTbl =
  Hashtbl.fold
    (fun u initu acc ->
      let prefixes = get_prefixes_from_expr initu in
      build_prefix_map u prefixes acc) initTbl PrefixMap.empty

let groupPrefixesByVertices (umap: AdjGraph.VertexSet.t PrefixMap.t) : PrefixSetSet.t =
  let reverseMap : PrefixSet.t AdjGraph.VertexSetMap.t =
    PrefixMap.fold (fun u vhat acc ->
        AdjGraph.VertexSetMap.modify_opt vhat (fun us -> match us with
                                          | None -> Some (PrefixSet.singleton u)
                                          | Some us -> Some (PrefixSet.add u us)) acc)
                 umap AdjGraph.VertexSetMap.empty in
  AdjGraph.VertexSetMap.fold (fun _ v acc -> PrefixSetSet.add v acc)
                       reverseMap PrefixSetSet.empty
  
