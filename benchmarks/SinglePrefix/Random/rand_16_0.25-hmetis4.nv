(* vim: set syntax=ocaml: *)
(* hMETIS-partitioned version of rand_16_0.25.nv with 4 partitions *)
(* Automatically generated by gen_part_nv.py *)
(* Generated by topzoo.py *)

type bgpType = {aslen: int; bgpAd: int8; comms: set[int]; lp: int; med: int;}

type attribute = option[bgpType]

let nodes = 16

let edges = {
  5-0; (* None,5 --> None,0 *)
  15-0; (* None,15 --> None,0 *)
  0-1; (* None,0 --> None,1 *)
  2-1; (* None,2 --> None,1 *)
  4-1; (* None,4 --> None,1 *)
  6-1; (* None,6 --> None,1 *)
  10-1; (* None,10 --> None,1 *)
  12-1; (* None,12 --> None,1 *)
  1-2; (* None,1 --> None,2 *)
  3-2; (* None,3 --> None,2 *)
  4-2; (* None,4 --> None,2 *)
  6-2; (* None,6 --> None,2 *)
  9-2; (* None,9 --> None,2 *)
  11-2; (* None,11 --> None,2 *)
  10-3; (* None,10 --> None,3 *)
  3-4; (* None,3 --> None,4 *)
  4-15; (* None,4 --> None,15 *)
  8-4; (* None,8 --> None,4 *)
  0-5; (* None,0 --> None,5 *)
  8-5; (* None,8 --> None,5 *)
  10-5; (* None,10 --> None,5 *)
  11-5; (* None,11 --> None,5 *)
  15-5; (* None,15 --> None,5 *)
  10-6; (* None,10 --> None,6 *)
  14-6; (* None,14 --> None,6 *)
  3-7; (* None,3 --> None,7 *)
  13-7; (* None,13 --> None,7 *)
  5-8; (* None,5 --> None,8 *)
  6-8; (* None,6 --> None,8 *)
  13-8; (* None,13 --> None,8 *)
  14-8; (* None,14 --> None,8 *)
  3-9; (* None,3 --> None,9 *)
  8-9; (* None,8 --> None,9 *)
  9-15; (* None,9 --> None,15 *)
  11-9; (* None,11 --> None,9 *)
  15-9; (* None,15 --> None,9 *)
  4-10; (* None,4 --> None,10 *)
  9-10; (* None,9 --> None,10 *)
  10-15; (* None,10 --> None,15 *)
  11-10; (* None,11 --> None,10 *)
  14-10; (* None,14 --> None,10 *)
  15-10; (* None,15 --> None,10 *)
  3-11; (* None,3 --> None,11 *)
  3-12; (* None,3 --> None,12 *)
  5-12; (* None,5 --> None,12 *)
  7-12; (* None,7 --> None,12 *)
  10-12; (* None,10 --> None,12 *)
  11-12; (* None,11 --> None,12 *)
  13-12; (* None,13 --> None,12 *)
  0-13; (* None,0 --> None,13 *)
  6-13; (* None,6 --> None,13 *)
  9-13; (* None,9 --> None,13 *)
  0-14; (* None,0 --> None,14 *)
  8-14; (* None,8 --> None,14 *)
  9-14; (* None,9 --> None,14 *)
  15-14; (* None,15 --> None,14 *)
}

let init n = if n = 0n then Some {  aslen= 0u32; bgpAd= 20u8; comms= { _ |-> false }; lp= 100u32; med= 80u32; } else None

let pickOption f x y =
  match (x,y) with
  | (None, None) -> None
  | (None, Some _) -> y  | (Some _, None) -> x
  | (Some a, Some b) -> Some (f a b)

let betterBgp b1 b2 =
  if b1.lp > b2.lp then b1
  else if b2.lp > b1.lp then b2
  else if b1.aslen < b2.aslen then b1
  else if b2.aslen < b1.aslen then b2  else if b1.med >= b2.med then b1 else b2

let mergeBgp x y = pickOption betterBgp x y

let merge n x y = mergeBgp x y

(* Simple shortest-path routing. *)
let transferBgp e x =
  match x with
  | None -> None
  | Some b -> Some {b with aslen = b.aslen + 1}

let trans e x = transferBgp e x

let assert_node u v = match v with | None -> false | _ -> true

let sol = solution { init = init; trans = trans; merge = merge; interface = interface; rtrans = trans }

(* {None,0=0, None,1=1, None,2=2, None,3=3, None,4=4, None,5=5, None,6=6, None,7=7, None,8=8, None,9=9, None,10=10, None,11=11, None,12=12, None,13=13, None,14=14, None,15=15} *)

assert foldNodes (fun u v acc -> acc && assert_node u v) sol true
let partition node = match node with
  | 2n -> 0
  | 3n -> 0
  | 9n -> 0
  | 11n -> 0
  | 7n -> 1
  | 12n -> 1
  | 13n -> 1
  | 1n -> 2
  | 4n -> 2
  | 6n -> 2
  | 10n -> 2
  | 5n -> 3
  | 8n -> 3
  | 14n -> 3
  | 15n -> 3
  | 0n -> 3

let interface edge a =
  match edge with
  | 0~1 -> a = Some {  aslen= 0u32; bgpAd= 20u8; comms= { _ |-> false }; lp= 100u32; med= 80u32; }
  | 0~13 -> a = Some {  aslen= 0u32; bgpAd= 20u8; comms= { _ |-> false }; lp= 100u32; med= 80u32; }
  | 1~2 -> a = Some {  aslen= 1u32; bgpAd= 20u8; comms= { _ |-> false }; lp= 100u32; med= 80u32; }
  | 2~1 -> a = Some {  aslen= 2u32; bgpAd= 20u8; comms= { _ |-> false }; lp= 100u32; med= 80u32; }
  | 3~4 -> a = Some {  aslen= 3u32; bgpAd= 20u8; comms= { _ |-> false }; lp= 100u32; med= 80u32; }
  | 3~7 -> a = Some {  aslen= 3u32; bgpAd= 20u8; comms= { _ |-> false }; lp= 100u32; med= 80u32; }
  | 3~12 -> a = Some {  aslen= 3u32; bgpAd= 20u8; comms= { _ |-> false }; lp= 100u32; med= 80u32; }
  | 4~2 -> a = Some {  aslen= 3u32; bgpAd= 20u8; comms= { _ |-> false }; lp= 100u32; med= 80u32; }
  | 4~15 -> a = Some {  aslen= 3u32; bgpAd= 20u8; comms= { _ |-> false }; lp= 100u32; med= 80u32; }
  | 5~12 -> a = Some {  aslen= 1u32; bgpAd= 20u8; comms= { _ |-> false }; lp= 100u32; med= 80u32; }
  | 6~2 -> a = Some {  aslen= 2u32; bgpAd= 20u8; comms= { _ |-> false }; lp= 100u32; med= 80u32; }
  | 6~8 -> a = Some {  aslen= 2u32; bgpAd= 20u8; comms= { _ |-> false }; lp= 100u32; med= 80u32; }
  | 6~13 -> a = Some {  aslen= 2u32; bgpAd= 20u8; comms= { _ |-> false }; lp= 100u32; med= 80u32; }
  | 8~4 -> a = Some {  aslen= 2u32; bgpAd= 20u8; comms= { _ |-> false }; lp= 100u32; med= 80u32; }
  | 8~9 -> a = Some {  aslen= 2u32; bgpAd= 20u8; comms= { _ |-> false }; lp= 100u32; med= 80u32; }
  | 9~10 -> a = Some {  aslen= 3u32; bgpAd= 20u8; comms= { _ |-> false }; lp= 100u32; med= 80u32; }
  | 9~13 -> a = Some {  aslen= 3u32; bgpAd= 20u8; comms= { _ |-> false }; lp= 100u32; med= 80u32; }
  | 9~14 -> a = Some {  aslen= 3u32; bgpAd= 20u8; comms= { _ |-> false }; lp= 100u32; med= 80u32; }
  | 9~15 -> a = Some {  aslen= 3u32; bgpAd= 20u8; comms= { _ |-> false }; lp= 100u32; med= 80u32; }
  | 10~3 -> a = Some {  aslen= 2u32; bgpAd= 20u8; comms= { _ |-> false }; lp= 100u32; med= 80u32; }
  | 10~5 -> a = Some {  aslen= 2u32; bgpAd= 20u8; comms= { _ |-> false }; lp= 100u32; med= 80u32; }
  | 10~12 -> a = Some {  aslen= 2u32; bgpAd= 20u8; comms= { _ |-> false }; lp= 100u32; med= 80u32; }
  | 10~15 -> a = Some {  aslen= 2u32; bgpAd= 20u8; comms= { _ |-> false }; lp= 100u32; med= 80u32; }
  | 11~5 -> a = Some {  aslen= 4u32; bgpAd= 20u8; comms= { _ |-> false }; lp= 100u32; med= 80u32; }
  | 11~10 -> a = Some {  aslen= 4u32; bgpAd= 20u8; comms= { _ |-> false }; lp= 100u32; med= 80u32; }
  | 11~12 -> a = Some {  aslen= 4u32; bgpAd= 20u8; comms= { _ |-> false }; lp= 100u32; med= 80u32; }
  | 12~1 -> a = Some {  aslen= 2u32; bgpAd= 20u8; comms= { _ |-> false }; lp= 100u32; med= 80u32; }
  | 13~8 -> a = Some {  aslen= 1u32; bgpAd= 20u8; comms= { _ |-> false }; lp= 100u32; med= 80u32; }
  | 14~6 -> a = Some {  aslen= 1u32; bgpAd= 20u8; comms= { _ |-> false }; lp= 100u32; med= 80u32; }
  | 14~10 -> a = Some {  aslen= 1u32; bgpAd= 20u8; comms= { _ |-> false }; lp= 100u32; med= 80u32; }
  | 15~9 -> a = Some {  aslen= 3u32; bgpAd= 20u8; comms= { _ |-> false }; lp= 100u32; med= 80u32; }
  | 15~10 -> a = Some {  aslen= 3u32; bgpAd= 20u8; comms= { _ |-> false }; lp= 100u32; med= 80u32; }
